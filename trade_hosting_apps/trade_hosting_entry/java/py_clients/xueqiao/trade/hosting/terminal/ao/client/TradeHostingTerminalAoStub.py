#
# -*- coding: utf-8 -*-
# Autogenerated by Thrift Compiler (0.9.1)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

import sys
import socket
from thrift import Thrift
from thrift.transport import TSocket
from thrift.transport import TTransport
from thrift.protocol import TCompactProtocol
from thrift.transport.TTransport import TTransportException
from comm.ttypes import *
from page.ttypes import *
from xueqiao.trade.hosting.ttypes import *
from xueqiao.trade.hosting.arbitrage.thriftapi.ttypes import *
from xueqiao.trade.hosting.asset.thriftapi.ttypes import *
from xueqiao.trade.hosting.history.thriftapi.ttypes import *
from xueqiao.trade.hosting.tradeaccount.data.ttypes import *
from xueqiao.trade.hosting.position.adjust.thriftapi.ttypes import *
from xueqiao.trade.hosting.position.adjust.assign.thriftapi.ttypes import *
from xueqiao.trade.hosting.position.statis.ttypes import *
from xueqiao.trade.hosting.tasknote.thriftapi.ttypes import *
from xueqiao.mailbox.user.message.thriftapi.ttypes import *
from xueqiao.trade.hosting.risk.manager.thriftapi.ttypes import *
from xueqiao.trade.hosting.position.fee.thriftapi.ttypes import *
from xueqiao.trade.hosting.terminal.ao.ttypes import *
from xueqiao.trade.hosting.terminal.ao import TradeHostingTerminalAo

PYTHON_SUPPORT_DIR='/usr/local/soldier/route_agent'
if not (PYTHON_SUPPORT_DIR in sys.path):
  sys.path.append(PYTHON_SUPPORT_DIR)
from route_finder_python import *

class TradeHostingTerminalAoStub:
  def __init__(self):
    self.__peerAddr = None

  def setPeerAddr(self, peerAddr):
    self.__peerAddr = peerAddr

  def __getServiceAddr(self, methodName='', routeKey=0):
    if self.__peerAddr != None and self.__peerAddr !='':
      return self.__peerAddr
    return route_finder.GetRouteIp(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, methodName, routeKey)

  def getHostingUserPage(self, routeKey, timeout, landingInfo,queryOption,pageOption,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('getHostingUserPage', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.getHostingUserPage(platformArgs,landingInfo,queryOption,pageOption,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'getHostingUserPage', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'getHostingUserPage', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def heartBeat(self, routeKey, timeout, landingInfo,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('heartBeat', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.heartBeat(platformArgs,landingInfo,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'heartBeat', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'heartBeat', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def logout(self, routeKey, timeout, landingInfo,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('logout', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.logout(platformArgs,landingInfo,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'logout', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'logout', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def getComposeViewDetails(self, routeKey, timeout, landingInfo,composeGraphIds,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('getComposeViewDetails', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.getComposeViewDetails(platformArgs,landingInfo,composeGraphIds,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'getComposeViewDetails', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'getComposeViewDetails', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def changeComposeViewPrecisionNumber(self, routeKey, timeout, landingInfo,composeGraphId,precisionNumber,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('changeComposeViewPrecisionNumber', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.changeComposeViewPrecisionNumber(platformArgs,landingInfo,composeGraphId,precisionNumber,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'changeComposeViewPrecisionNumber', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'changeComposeViewPrecisionNumber', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def createComposeGraph(self, routeKey, timeout, landingInfo,newGraph,aliasName,precisionNumber,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('createComposeGraph', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.createComposeGraph(platformArgs,landingInfo,newGraph,aliasName,precisionNumber,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'createComposeGraph', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'createComposeGraph', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def delComposeView(self, routeKey, timeout, landingInfo,composeGraphId,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('delComposeView', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.delComposeView(platformArgs,landingInfo,composeGraphId,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'delComposeView', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'delComposeView', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def getComposeViewDetailPage(self, routeKey, timeout, landingInfo,queryOption,pageOption,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('getComposeViewDetailPage', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.getComposeViewDetailPage(platformArgs,landingInfo,queryOption,pageOption,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'getComposeViewDetailPage', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'getComposeViewDetailPage', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def getSameComposeGraphsPage(self, routeKey, timeout, landingInfo,graph,pageOption,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('getSameComposeGraphsPage', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.getSameComposeGraphsPage(platformArgs,landingInfo,graph,pageOption,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'getSameComposeGraphsPage', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'getSameComposeGraphsPage', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def addComposeViewBySearch(self, routeKey, timeout, landingInfo,composeGraphId,composeGraphKey,aliasName,precisionNumber,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('addComposeViewBySearch', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.addComposeViewBySearch(platformArgs,landingInfo,composeGraphId,composeGraphKey,aliasName,precisionNumber,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'addComposeViewBySearch', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'addComposeViewBySearch', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def subscribeComposeViewQuotation(self, routeKey, timeout, landingInfo,composeGraphId,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('subscribeComposeViewQuotation', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.subscribeComposeViewQuotation(platformArgs,landingInfo,composeGraphId,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'subscribeComposeViewQuotation', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'subscribeComposeViewQuotation', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def unSubscribeComposeViewQuotation(self, routeKey, timeout, landingInfo,composeGraphId,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('unSubscribeComposeViewQuotation', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.unSubscribeComposeViewQuotation(platformArgs,landingInfo,composeGraphId,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'unSubscribeComposeViewQuotation', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'unSubscribeComposeViewQuotation', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def changeComposeViewAliasName(self, routeKey, timeout, landingInfo,composeGraphId,aliasName,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('changeComposeViewAliasName', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.changeComposeViewAliasName(platformArgs,landingInfo,composeGraphId,aliasName,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'changeComposeViewAliasName', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'changeComposeViewAliasName', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def getComposeGraphs(self, routeKey, timeout, landingInfo,composeGraphIds,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('getComposeGraphs', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.getComposeGraphs(platformArgs,landingInfo,composeGraphIds,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'getComposeGraphs', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'getComposeGraphs', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def addComposeViewByShare(self, routeKey, timeout, landingInfo,composeGraphId,aliasName,precisionNumber,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('addComposeViewByShare', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.addComposeViewByShare(platformArgs,landingInfo,composeGraphId,aliasName,precisionNumber,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'addComposeViewByShare', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'addComposeViewByShare', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def addTradeAccount(self, routeKey, timeout, landingInfo,newAccount,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('addTradeAccount', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.addTradeAccount(platformArgs,landingInfo,newAccount,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'addTradeAccount', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'addTradeAccount', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def disableTradeAccount(self, routeKey, timeout, landingInfo,tradeAccountId,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('disableTradeAccount', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.disableTradeAccount(platformArgs,landingInfo,tradeAccountId,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'disableTradeAccount', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'disableTradeAccount', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def getTradeAccountPage(self, routeKey, timeout, landingInfo,queryOption,pageOption,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('getTradeAccountPage', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.getTradeAccountPage(platformArgs,landingInfo,queryOption,pageOption,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'getTradeAccountPage', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'getTradeAccountPage', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def enableTradeAccount(self, routeKey, timeout, landingInfo,tradeAccountId,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('enableTradeAccount', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.enableTradeAccount(platformArgs,landingInfo,tradeAccountId,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'enableTradeAccount', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'enableTradeAccount', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def updateTradeAccountInfo(self, routeKey, timeout, landingInfo,updateAccount,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('updateTradeAccountInfo', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.updateTradeAccountInfo(platformArgs,landingInfo,updateAccount,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'updateTradeAccountInfo', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'updateTradeAccountInfo', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def rmTradeAccount(self, routeKey, timeout, landingInfo,tradeAccountId,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('rmTradeAccount', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.rmTradeAccount(platformArgs,landingInfo,tradeAccountId,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'rmTradeAccount', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'rmTradeAccount', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def getHostingOrderRouteTree(self, routeKey, timeout, landingInfo,subAccountId,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('getHostingOrderRouteTree', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.getHostingOrderRouteTree(platformArgs,landingInfo,subAccountId,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'getHostingOrderRouteTree', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'getHostingOrderRouteTree', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def updateHostingOrderRouteTree(self, routeKey, timeout, landingInfo,subAccountId,routeTree,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('updateHostingOrderRouteTree', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.updateHostingOrderRouteTree(platformArgs,landingInfo,subAccountId,routeTree,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'updateHostingOrderRouteTree', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'updateHostingOrderRouteTree', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def getHostingOrderRouteTreeVersion(self, routeKey, timeout, landingInfo,subAccountId,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('getHostingOrderRouteTreeVersion', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.getHostingOrderRouteTreeVersion(platformArgs,landingInfo,subAccountId,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'getHostingOrderRouteTreeVersion', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'getHostingOrderRouteTreeVersion', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def createXQOrder(self, routeKey, timeout, landingInfo,subAccountId,orderId,orderType,orderTarget,orderDetail,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('createXQOrder', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.createXQOrder(platformArgs,landingInfo,subAccountId,orderId,orderType,orderTarget,orderDetail,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'createXQOrder', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'createXQOrder', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def batchSuspendXQOrders(self, routeKey, timeout, landingInfo,orderIds,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('batchSuspendXQOrders', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.batchSuspendXQOrders(platformArgs,landingInfo,orderIds,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'batchSuspendXQOrders', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'batchSuspendXQOrders', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def batchResumeXQOrders(self, routeKey, timeout, landingInfo,orderIds,resumeModes,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('batchResumeXQOrders', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.batchResumeXQOrders(platformArgs,landingInfo,orderIds,resumeModes,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'batchResumeXQOrders', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'batchResumeXQOrders', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def batchCancelXQOrders(self, routeKey, timeout, landingInfo,orderIds,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('batchCancelXQOrders', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.batchCancelXQOrders(platformArgs,landingInfo,orderIds,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'batchCancelXQOrders', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'batchCancelXQOrders', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def getEffectXQOrderWithTradeListPage(self, routeKey, timeout, landingInfo,qryOption,pageOption,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('getEffectXQOrderWithTradeListPage', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.getEffectXQOrderWithTradeListPage(platformArgs,landingInfo,qryOption,pageOption,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'getEffectXQOrderWithTradeListPage', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'getEffectXQOrderWithTradeListPage', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def getXQOrderWithTradeLists(self, routeKey, timeout, landingInfo,orderIds,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('getXQOrderWithTradeLists', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.getXQOrderWithTradeLists(platformArgs,landingInfo,orderIds,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'getXQOrderWithTradeLists', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'getXQOrderWithTradeLists', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def getXQOrderExecDetail(self, routeKey, timeout, landingInfo,orderId,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('getXQOrderExecDetail', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.getXQOrderExecDetail(platformArgs,landingInfo,orderId,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'getXQOrderExecDetail', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'getXQOrderExecDetail', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def getXQOrderHisPage(self, routeKey, timeout, landingInfo,qryOption,pageOption,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('getXQOrderHisPage', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.getXQOrderHisPage(platformArgs,landingInfo,qryOption,pageOption,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'getXQOrderHisPage', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'getXQOrderHisPage', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def getXQTradeHisPage(self, routeKey, timeout, landingInfo,qryOption,pageOption,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('getXQTradeHisPage', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.getXQTradeHisPage(platformArgs,landingInfo,qryOption,pageOption,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'getXQTradeHisPage', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'getXQTradeHisPage', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def getUserSetting(self, routeKey, timeout, landingInfo,key,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('getUserSetting', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.getUserSetting(platformArgs,landingInfo,key,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'getUserSetting', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'getUserSetting', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def updateUserSetting(self, routeKey, timeout, landingInfo,key,setting,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('updateUserSetting', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.updateUserSetting(platformArgs,landingInfo,key,setting,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'updateUserSetting', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'updateUserSetting', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def getUserSettingVersion(self, routeKey, timeout, landingInfo,key,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('getUserSettingVersion', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.getUserSettingVersion(platformArgs,landingInfo,key,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'getUserSettingVersion', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'getUserSettingVersion', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def getSAWRUTListPage(self, routeKey, timeout, landingInfo,queryOption,pageOption,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('getSAWRUTListPage', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.getSAWRUTListPage(platformArgs,landingInfo,queryOption,pageOption,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'getSAWRUTListPage', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'getSAWRUTListPage', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def getSARUTBySubAccountId(self, routeKey, timeout, landingInfo,subAccountIds,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('getSARUTBySubAccountId', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.getSARUTBySubAccountId(platformArgs,landingInfo,subAccountIds,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'getSARUTBySubAccountId', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'getSARUTBySubAccountId', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def getSARUTBySubUserId(self, routeKey, timeout, landingInfo,subUserIds,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('getSARUTBySubUserId', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.getSARUTBySubUserId(platformArgs,landingInfo,subUserIds,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'getSARUTBySubUserId', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'getSARUTBySubUserId', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def assignSubAccountRelatedUsers(self, routeKey, timeout, landingInfo,subAccountId,relatedSubUserIds,unRelatedSubUserIds,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('assignSubAccountRelatedUsers', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.assignSubAccountRelatedUsers(platformArgs,landingInfo,subAccountId,relatedSubUserIds,unRelatedSubUserIds,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'assignSubAccountRelatedUsers', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'assignSubAccountRelatedUsers', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def renameSubAccount(self, routeKey, timeout, landingInfo,subAccountId,subAccountName,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('renameSubAccount', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.renameSubAccount(platformArgs,landingInfo,subAccountId,subAccountName,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'renameSubAccount', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'renameSubAccount', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def createSubAccount(self, routeKey, timeout, landingInfo,newSubAccount,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('createSubAccount', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.createSubAccount(platformArgs,landingInfo,newSubAccount,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'createSubAccount', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'createSubAccount', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def getHostingSledContractPosition(self, routeKey, timeout, landingInfo,option,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('getHostingSledContractPosition', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.getHostingSledContractPosition(platformArgs,landingInfo,option,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'getHostingSledContractPosition', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'getHostingSledContractPosition', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def getHostingSubAccountFund(self, routeKey, timeout, landingInfo,option,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('getHostingSubAccountFund', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.getHostingSubAccountFund(platformArgs,landingInfo,option,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'getHostingSubAccountFund', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'getHostingSubAccountFund', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def changeSubAccountFund(self, routeKey, timeout, landingInfo,fundChange,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('changeSubAccountFund', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.changeSubAccountFund(platformArgs,landingInfo,fundChange,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'changeSubAccountFund', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'changeSubAccountFund', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def setSubAccountCreditAmount(self, routeKey, timeout, landingInfo,amountChange,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('setSubAccountCreditAmount', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.setSubAccountCreditAmount(platformArgs,landingInfo,amountChange,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'setSubAccountCreditAmount', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'setSubAccountCreditAmount', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def getAssetPositionTradeDetail(self, routeKey, timeout, landingInfo,option,pageOption,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('getAssetPositionTradeDetail', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.getAssetPositionTradeDetail(platformArgs,landingInfo,option,pageOption,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'getAssetPositionTradeDetail', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'getAssetPositionTradeDetail', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def getHostingSubAccountMoneyRecord(self, routeKey, timeout, landingInfo,option,pageOption,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('getHostingSubAccountMoneyRecord', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.getHostingSubAccountMoneyRecord(platformArgs,landingInfo,option,pageOption,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'getHostingSubAccountMoneyRecord', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'getHostingSubAccountMoneyRecord', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def getSubAccountFundHistory(self, routeKey, timeout, landingInfo,option,pageOption,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('getSubAccountFundHistory', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.getSubAccountFundHistory(platformArgs,landingInfo,option,pageOption,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'getSubAccountFundHistory', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'getSubAccountFundHistory', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def getSubAccountPositionHistory(self, routeKey, timeout, landingInfo,option,pageOption,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('getSubAccountPositionHistory', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.getSubAccountPositionHistory(platformArgs,landingInfo,option,pageOption,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'getSubAccountPositionHistory', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'getSubAccountPositionHistory', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def getSubAccountPositionHistoryTradeDetail(self, routeKey, timeout, landingInfo,option,pageOption,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('getSubAccountPositionHistoryTradeDetail', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.getSubAccountPositionHistoryTradeDetail(platformArgs,landingInfo,option,pageOption,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'getSubAccountPositionHistoryTradeDetail', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'getSubAccountPositionHistoryTradeDetail', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def deleteExpiredContractPosition(self, routeKey, timeout, landingInfo,subAccountId,sledContractId,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('deleteExpiredContractPosition', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.deleteExpiredContractPosition(platformArgs,landingInfo,subAccountId,sledContractId,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'deleteExpiredContractPosition', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'deleteExpiredContractPosition', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def getTradeAccountFundNow(self, routeKey, timeout, landingInfo,tradeAccountId,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('getTradeAccountFundNow', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.getTradeAccountFundNow(platformArgs,landingInfo,tradeAccountId,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'getTradeAccountFundNow', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'getTradeAccountFundNow', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def getTradeAccountFundHis(self, routeKey, timeout, landingInfo,tradeAccountId,fundDateBegin,fundDateEnd,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('getTradeAccountFundHis', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.getTradeAccountFundHis(platformArgs,landingInfo,tradeAccountId,fundDateBegin,fundDateEnd,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'getTradeAccountFundHis', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'getTradeAccountFundHis', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def getTradeAccountSettlementInfos(self, routeKey, timeout, landingInfo,tradeAccountId,settlementDateBegin,settlementDateEnd,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('getTradeAccountSettlementInfos', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.getTradeAccountSettlementInfos(platformArgs,landingInfo,tradeAccountId,settlementDateBegin,settlementDateEnd,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'getTradeAccountSettlementInfos', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'getTradeAccountSettlementInfos', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def getTradeAccountSettlementInfosWithRelatedTime(self, routeKey, timeout, landingInfo,tradeAccountId,settlementDateBegin,settlementDateEnd,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('getTradeAccountSettlementInfosWithRelatedTime', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.getTradeAccountSettlementInfosWithRelatedTime(platformArgs,landingInfo,tradeAccountId,settlementDateBegin,settlementDateEnd,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'getTradeAccountSettlementInfosWithRelatedTime', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'getTradeAccountSettlementInfosWithRelatedTime', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def getTradeAccountPositionTradeDetail(self, routeKey, timeout, landingInfo,option,pageOption,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('getTradeAccountPositionTradeDetail', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.getTradeAccountPositionTradeDetail(platformArgs,landingInfo,option,pageOption,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'getTradeAccountPositionTradeDetail', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'getTradeAccountPositionTradeDetail', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def reqPositionVerify(self, routeKey, timeout, landingInfo,option,pageOption,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('reqPositionVerify', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.reqPositionVerify(platformArgs,landingInfo,option,pageOption,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'reqPositionVerify', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'reqPositionVerify', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def reqPositionDifference(self, routeKey, timeout, landingInfo,option,pageOption,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('reqPositionDifference', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.reqPositionDifference(platformArgs,landingInfo,option,pageOption,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'reqPositionDifference', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'reqPositionDifference', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def manualInputPosition(self, routeKey, timeout, landingInfo,positionManualInputs,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('manualInputPosition', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.manualInputPosition(platformArgs,landingInfo,positionManualInputs,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'manualInputPosition', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'manualInputPosition', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def reqPositionUnassigned(self, routeKey, timeout, landingInfo,option,pageOption,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('reqPositionUnassigned', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.reqPositionUnassigned(platformArgs,landingInfo,option,pageOption,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'reqPositionUnassigned', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'reqPositionUnassigned', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def assignPosition(self, routeKey, timeout, landingInfo,assignOption,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('assignPosition', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.assignPosition(platformArgs,landingInfo,assignOption,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'assignPosition', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'assignPosition', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def reqPositionEditLock(self, routeKey, timeout, landingInfo,lockKey,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('reqPositionEditLock', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.reqPositionEditLock(platformArgs,landingInfo,lockKey,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'reqPositionEditLock', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'reqPositionEditLock', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def addPositionEditLock(self, routeKey, timeout, landingInfo,positionEditLock,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('addPositionEditLock', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.addPositionEditLock(platformArgs,landingInfo,positionEditLock,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'addPositionEditLock', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'addPositionEditLock', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def removePositionEditLock(self, routeKey, timeout, landingInfo,positionEditLock,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('removePositionEditLock', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.removePositionEditLock(platformArgs,landingInfo,positionEditLock,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'removePositionEditLock', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'removePositionEditLock', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def reqDailyPositionDifference(self, routeKey, timeout, landingInfo,option,pageOption,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('reqDailyPositionDifference', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.reqDailyPositionDifference(platformArgs,landingInfo,option,pageOption,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'reqDailyPositionDifference', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'reqDailyPositionDifference', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def updateDailyPositionDifferenceNote(self, routeKey, timeout, landingInfo,difference,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('updateDailyPositionDifferenceNote', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.updateDailyPositionDifferenceNote(platformArgs,landingInfo,difference,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'updateDailyPositionDifferenceNote', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'updateDailyPositionDifferenceNote', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def reqPositionAssigned(self, routeKey, timeout, landingInfo,option,pageOption,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('reqPositionAssigned', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.reqPositionAssigned(platformArgs,landingInfo,option,pageOption,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'reqPositionAssigned', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'reqPositionAssigned', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def contructCompose(self, routeKey, timeout, landingInfo,contructComposeReq,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('contructCompose', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.contructCompose(platformArgs,landingInfo,contructComposeReq,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'contructCompose', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'contructCompose', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def disassembleCompose(self, routeKey, timeout, landingInfo,disassembleComposePositionReq,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('disassembleCompose', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.disassembleCompose(platformArgs,landingInfo,disassembleComposePositionReq,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'disassembleCompose', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'disassembleCompose', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def batchClosePosition(self, routeKey, timeout, landingInfo,batchClosedPositionReq,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('batchClosePosition', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.batchClosePosition(platformArgs,landingInfo,batchClosedPositionReq,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'batchClosePosition', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'batchClosePosition', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def recoverClosedPosition(self, routeKey, timeout, landingInfo,subAccountId,targetKey,targetType,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('recoverClosedPosition', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.recoverClosedPosition(platformArgs,landingInfo,subAccountId,targetKey,targetType,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'recoverClosedPosition', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'recoverClosedPosition', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def mergeToCompose(self, routeKey, timeout, landingInfo,mergeToComposeReq,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('mergeToCompose', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.mergeToCompose(platformArgs,landingInfo,mergeToComposeReq,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'mergeToCompose', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'mergeToCompose', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def deleteExpiredStatContractPosition(self, routeKey, timeout, landingInfo,subAccountId,sledContractId,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('deleteExpiredStatContractPosition', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.deleteExpiredStatContractPosition(platformArgs,landingInfo,subAccountId,sledContractId,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'deleteExpiredStatContractPosition', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'deleteExpiredStatContractPosition', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def queryStatPositionSummaryPage(self, routeKey, timeout, landingInfo,queryOption,pageOption,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('queryStatPositionSummaryPage', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.queryStatPositionSummaryPage(platformArgs,landingInfo,queryOption,pageOption,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'queryStatPositionSummaryPage', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'queryStatPositionSummaryPage', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def queryStatPositionItemPage(self, routeKey, timeout, landingInfo,queryOption,pageOption,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('queryStatPositionItemPage', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.queryStatPositionItemPage(platformArgs,landingInfo,queryOption,pageOption,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'queryStatPositionItemPage', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'queryStatPositionItemPage', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def queryCurrentDayStatClosedPositionPage(self, routeKey, timeout, landingInfo,subAccountId,targetKey,targetType,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('queryCurrentDayStatClosedPositionPage', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.queryCurrentDayStatClosedPositionPage(platformArgs,landingInfo,subAccountId,targetKey,targetType,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'queryCurrentDayStatClosedPositionPage', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'queryCurrentDayStatClosedPositionPage', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def queryStatClosedPositionDetail(self, routeKey, timeout, landingInfo,queryOption,pageOption,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('queryStatClosedPositionDetail', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.queryStatClosedPositionDetail(platformArgs,landingInfo,queryOption,pageOption,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'queryStatClosedPositionDetail', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'queryStatClosedPositionDetail', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def queryArchivedClosedPositionPage(self, routeKey, timeout, landingInfo,queryOption,pageOption,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('queryArchivedClosedPositionPage', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.queryArchivedClosedPositionPage(platformArgs,landingInfo,queryOption,pageOption,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'queryArchivedClosedPositionPage', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'queryArchivedClosedPositionPage', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def queryArchivedClosedPositionDetail(self, routeKey, timeout, landingInfo,queryOption,pageOption,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('queryArchivedClosedPositionDetail', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.queryArchivedClosedPositionDetail(platformArgs,landingInfo,queryOption,pageOption,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'queryArchivedClosedPositionDetail', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'queryArchivedClosedPositionDetail', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def queryStatPositionSummaryExPage(self, routeKey, timeout, landingInfo,queryOption,pageOption,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('queryStatPositionSummaryExPage', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.queryStatPositionSummaryExPage(platformArgs,landingInfo,queryOption,pageOption,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'queryStatPositionSummaryExPage', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'queryStatPositionSummaryExPage', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def queryStatPositionUnitPage(self, routeKey, timeout, landingInfo,queryOption,pageOption,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('queryStatPositionUnitPage', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.queryStatPositionUnitPage(platformArgs,landingInfo,queryOption,pageOption,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'queryStatPositionUnitPage', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'queryStatPositionUnitPage', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def queryHistoryClosedPositionPage(self, routeKey, timeout, landingInfo,queryOption,pageOption,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('queryHistoryClosedPositionPage', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.queryHistoryClosedPositionPage(platformArgs,landingInfo,queryOption,pageOption,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'queryHistoryClosedPositionPage', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'queryHistoryClosedPositionPage', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def queryHistoryClosedPositionDetail(self, routeKey, timeout, landingInfo,queryOption,pageOption,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('queryHistoryClosedPositionDetail', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.queryHistoryClosedPositionDetail(platformArgs,landingInfo,queryOption,pageOption,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'queryHistoryClosedPositionDetail', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'queryHistoryClosedPositionDetail', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def getXQTradeLameTaskNotePage(self, routeKey, timeout, landingInfo,qryOption,pageOption,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('getXQTradeLameTaskNotePage', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.getXQTradeLameTaskNotePage(platformArgs,landingInfo,qryOption,pageOption,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'getXQTradeLameTaskNotePage', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'getXQTradeLameTaskNotePage', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def batchDeleteXQTradeLameTaskNotes(self, routeKey, timeout, landingInfo,subAccountId,xqTradeIds,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('batchDeleteXQTradeLameTaskNotes', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.batchDeleteXQTradeLameTaskNotes(platformArgs,landingInfo,subAccountId,xqTradeIds,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'batchDeleteXQTradeLameTaskNotes', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'batchDeleteXQTradeLameTaskNotes', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def queryMailBoxMessage(self, routeKey, timeout, landingInfo,option,pageOption,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('queryMailBoxMessage', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.queryMailBoxMessage(platformArgs,landingInfo,option,pageOption,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'queryMailBoxMessage', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'queryMailBoxMessage', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def markMessageAsRead(self, routeKey, timeout, landingInfo,hostingMessageIds,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('markMessageAsRead', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.markMessageAsRead(platformArgs,landingInfo,hostingMessageIds,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'markMessageAsRead', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'markMessageAsRead', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def getAllSupportedItems(self, routeKey, timeout, landingInfo,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('getAllSupportedItems', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.getAllSupportedItems(platformArgs,landingInfo,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'getAllSupportedItems', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'getAllSupportedItems', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def getRiskRuleJointVersion(self, routeKey, timeout, landingInfo,subAccountId,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('getRiskRuleJointVersion', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.getRiskRuleJointVersion(platformArgs,landingInfo,subAccountId,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'getRiskRuleJointVersion', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'getRiskRuleJointVersion', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def getRiskRuleJoint(self, routeKey, timeout, landingInfo,subAccountId,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('getRiskRuleJoint', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.getRiskRuleJoint(platformArgs,landingInfo,subAccountId,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'getRiskRuleJoint', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'getRiskRuleJoint', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def batchSetSupportedItems(self, routeKey, timeout, landingInfo,subAccountId,version,openedItemIds,closedItemIds,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('batchSetSupportedItems', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.batchSetSupportedItems(platformArgs,landingInfo,subAccountId,version,openedItemIds,closedItemIds,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'batchSetSupportedItems', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'batchSetSupportedItems', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def batchSetTradedCommodityItems(self, routeKey, timeout, landingInfo,subAccountId,version,enabledCommodityIds,disabledCommodityIds,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('batchSetTradedCommodityItems', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.batchSetTradedCommodityItems(platformArgs,landingInfo,subAccountId,version,enabledCommodityIds,disabledCommodityIds,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'batchSetTradedCommodityItems', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'batchSetTradedCommodityItems', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def batchSetGlobalRules(self, routeKey, timeout, landingInfo,subAccountId,version,ruleItems,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('batchSetGlobalRules', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.batchSetGlobalRules(platformArgs,landingInfo,subAccountId,version,ruleItems,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'batchSetGlobalRules', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'batchSetGlobalRules', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def batchSetCommodityRules(self, routeKey, timeout, landingInfo,subAccountId,version,rules,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('batchSetCommodityRules', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.batchSetCommodityRules(platformArgs,landingInfo,subAccountId,version,rules,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'batchSetCommodityRules', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'batchSetCommodityRules', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def setRiskEnabled(self, routeKey, timeout, landingInfo,subAccountId,version,riskEnabled,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('setRiskEnabled', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.setRiskEnabled(platformArgs,landingInfo,subAccountId,version,riskEnabled,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'setRiskEnabled', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'setRiskEnabled', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def getRiskFrameDataInfo(self, routeKey, timeout, landingInfo,subAccountId,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('getRiskFrameDataInfo', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.getRiskFrameDataInfo(platformArgs,landingInfo,subAccountId,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'getRiskFrameDataInfo', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'getRiskFrameDataInfo', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def setGeneralMarginSetting(self, routeKey, timeout, landingInfo,marginSettings,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('setGeneralMarginSetting', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.setGeneralMarginSetting(platformArgs,landingInfo,marginSettings,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'setGeneralMarginSetting', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'setGeneralMarginSetting', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def setGeneralCommissionSetting(self, routeKey, timeout, landingInfo,commissionSettings,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('setGeneralCommissionSetting', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.setGeneralCommissionSetting(platformArgs,landingInfo,commissionSettings,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'setGeneralCommissionSetting', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'setGeneralCommissionSetting', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def addSpecMarginSetting(self, routeKey, timeout, landingInfo,marginSettings,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('addSpecMarginSetting', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.addSpecMarginSetting(platformArgs,landingInfo,marginSettings,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'addSpecMarginSetting', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'addSpecMarginSetting', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def addSpecCommissionSetting(self, routeKey, timeout, landingInfo,commissionSettings,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('addSpecCommissionSetting', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.addSpecCommissionSetting(platformArgs,landingInfo,commissionSettings,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'addSpecCommissionSetting', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'addSpecCommissionSetting', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def updateSpecMarginSetting(self, routeKey, timeout, landingInfo,marginSettings,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('updateSpecMarginSetting', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.updateSpecMarginSetting(platformArgs,landingInfo,marginSettings,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'updateSpecMarginSetting', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'updateSpecMarginSetting', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def updateSpecCommissionSetting(self, routeKey, timeout, landingInfo,commissionSettings,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('updateSpecCommissionSetting', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.updateSpecCommissionSetting(platformArgs,landingInfo,commissionSettings,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'updateSpecCommissionSetting', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'updateSpecCommissionSetting', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def deleteSpecMarginSetting(self, routeKey, timeout, landingInfo,subAccountId,commodityId,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('deleteSpecMarginSetting', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.deleteSpecMarginSetting(platformArgs,landingInfo,subAccountId,commodityId,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'deleteSpecMarginSetting', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'deleteSpecMarginSetting', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def deleteSpecCommissionSetting(self, routeKey, timeout, landingInfo,subAccountId,commodityId,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('deleteSpecCommissionSetting', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.deleteSpecCommissionSetting(platformArgs,landingInfo,subAccountId,commodityId,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'deleteSpecCommissionSetting', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'deleteSpecCommissionSetting', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def queryXQGeneralMarginSettings(self, routeKey, timeout, landingInfo,subAccountId,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('queryXQGeneralMarginSettings', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.queryXQGeneralMarginSettings(platformArgs,landingInfo,subAccountId,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'queryXQGeneralMarginSettings', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'queryXQGeneralMarginSettings', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def queryXQGeneralCommissionSettings(self, routeKey, timeout, landingInfo,subAccountId,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('queryXQGeneralCommissionSettings', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.queryXQGeneralCommissionSettings(platformArgs,landingInfo,subAccountId,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'queryXQGeneralCommissionSettings', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'queryXQGeneralCommissionSettings', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def queryXQSpecMarginSettingPage(self, routeKey, timeout, landingInfo,queryOptions,pageOption,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('queryXQSpecMarginSettingPage', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.queryXQSpecMarginSettingPage(platformArgs,landingInfo,queryOptions,pageOption,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'queryXQSpecMarginSettingPage', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'queryXQSpecMarginSettingPage', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def queryXQSpecCommissionSettingPage(self, routeKey, timeout, landingInfo,queryOptions,pageOption,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('queryXQSpecCommissionSettingPage', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.queryXQSpecCommissionSettingPage(platformArgs,landingInfo,queryOptions,pageOption,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'queryXQSpecCommissionSettingPage', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'queryXQSpecCommissionSettingPage', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def queryUpsideContractMarginPage(self, routeKey, timeout, landingInfo,queryOptions,pageOption,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('queryUpsideContractMarginPage', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.queryUpsideContractMarginPage(platformArgs,landingInfo,queryOptions,pageOption,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'queryUpsideContractMarginPage', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'queryUpsideContractMarginPage', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def queryUpsideContractCommissionPage(self, routeKey, timeout, landingInfo,queryOptions,pageOption,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('queryUpsideContractCommissionPage', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.queryUpsideContractCommissionPage(platformArgs,landingInfo,queryOptions,pageOption,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'queryUpsideContractCommissionPage', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'queryUpsideContractCommissionPage', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def queryXQContractMarginPage(self, routeKey, timeout, landingInfo,queryOptions,pageOption,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('queryXQContractMarginPage', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.queryXQContractMarginPage(platformArgs,landingInfo,queryOptions,pageOption,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'queryXQContractMarginPage', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'queryXQContractMarginPage', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def queryXQContractCommissionPage(self, routeKey, timeout, landingInfo,queryOptions,pageOption,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('queryXQContractCommissionPage', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingTerminalAo.Client(protocol)
    try:
      transport.open()
      result = client.queryXQContractCommissionPage(platformArgs,landingInfo,queryOptions,pageOption,)
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'queryXQContractCommissionPage', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingTerminalAo.TradeHostingTerminalAo_SERVICE_KEY, 'queryXQContractCommissionPage', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

