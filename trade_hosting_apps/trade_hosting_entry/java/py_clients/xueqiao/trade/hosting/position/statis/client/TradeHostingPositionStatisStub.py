#
# -*- coding: utf-8 -*-
# Autogenerated by Thrift Compiler (0.9.1)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

import sys
import socket
from thrift import Thrift
from thrift.transport import TSocket
from thrift.transport import TTransport
from thrift.protocol import TCompactProtocol
from thrift.transport.TTransport import TTransportException
from comm.ttypes import *
from page.ttypes import *
from xueqiao.trade.hosting.arbitrage.thriftapi.ttypes import *
from xueqiao.trade.hosting.position.adjust.assign.thriftapi.ttypes import *
from xueqiao.trade.hosting.position.statis.ttypes import *
from xueqiao.trade.hosting.position.statis import TradeHostingPositionStatis

PYTHON_SUPPORT_DIR='/usr/local/soldier/route_agent'
if not (PYTHON_SUPPORT_DIR in sys.path):
  sys.path.append(PYTHON_SUPPORT_DIR)
from route_finder_python import *

class TradeHostingPositionStatisStub:
  def __init__(self):
    self.__peerAddr = None

  def setPeerAddr(self, peerAddr):
    self.__peerAddr = peerAddr

  def __getServiceAddr(self, methodName='', routeKey=0):
    if self.__peerAddr != None and self.__peerAddr !='':
      return self.__peerAddr
    return route_finder.GetRouteIp(TradeHostingPositionStatis.TradeHostingPositionStatis_SERVICE_KEY, methodName, routeKey)

  def clearAll(self, routeKey, timeout, ):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('clearAll', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingPositionStatis.TradeHostingPositionStatis_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingPositionStatis.Client(protocol)
    try:
      transport.open()
      result = client.clearAll(platformArgs,)
      route_finder.UpdateCallInfo(TradeHostingPositionStatis.TradeHostingPositionStatis_SERVICE_KEY, 'clearAll', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingPositionStatis.TradeHostingPositionStatis_SERVICE_KEY, 'clearAll', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def contructCompose(self, routeKey, timeout, contructComposeReq,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('contructCompose', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingPositionStatis.TradeHostingPositionStatis_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingPositionStatis.Client(protocol)
    try:
      transport.open()
      result = client.contructCompose(platformArgs,contructComposeReq,)
      route_finder.UpdateCallInfo(TradeHostingPositionStatis.TradeHostingPositionStatis_SERVICE_KEY, 'contructCompose', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingPositionStatis.TradeHostingPositionStatis_SERVICE_KEY, 'contructCompose', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def disassembleCompose(self, routeKey, timeout, disassembleComposePositionReq,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('disassembleCompose', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingPositionStatis.TradeHostingPositionStatis_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingPositionStatis.Client(protocol)
    try:
      transport.open()
      result = client.disassembleCompose(platformArgs,disassembleComposePositionReq,)
      route_finder.UpdateCallInfo(TradeHostingPositionStatis.TradeHostingPositionStatis_SERVICE_KEY, 'disassembleCompose', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingPositionStatis.TradeHostingPositionStatis_SERVICE_KEY, 'disassembleCompose', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def batchClosePosition(self, routeKey, timeout, batchClosedPositionReq,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('batchClosePosition', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingPositionStatis.TradeHostingPositionStatis_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingPositionStatis.Client(protocol)
    try:
      transport.open()
      result = client.batchClosePosition(platformArgs,batchClosedPositionReq,)
      route_finder.UpdateCallInfo(TradeHostingPositionStatis.TradeHostingPositionStatis_SERVICE_KEY, 'batchClosePosition', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingPositionStatis.TradeHostingPositionStatis_SERVICE_KEY, 'batchClosePosition', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def recoverClosedPosition(self, routeKey, timeout, subAccountId,targetKey,targetType,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('recoverClosedPosition', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingPositionStatis.TradeHostingPositionStatis_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingPositionStatis.Client(protocol)
    try:
      transport.open()
      result = client.recoverClosedPosition(platformArgs,subAccountId,targetKey,targetType,)
      route_finder.UpdateCallInfo(TradeHostingPositionStatis.TradeHostingPositionStatis_SERVICE_KEY, 'recoverClosedPosition', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingPositionStatis.TradeHostingPositionStatis_SERVICE_KEY, 'recoverClosedPosition', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def assignPosition(self, routeKey, timeout, positionAssigned,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('assignPosition', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingPositionStatis.TradeHostingPositionStatis_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingPositionStatis.Client(protocol)
    try:
      transport.open()
      result = client.assignPosition(platformArgs,positionAssigned,)
      route_finder.UpdateCallInfo(TradeHostingPositionStatis.TradeHostingPositionStatis_SERVICE_KEY, 'assignPosition', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingPositionStatis.TradeHostingPositionStatis_SERVICE_KEY, 'assignPosition', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def mergeToCompose(self, routeKey, timeout, mergeToComposeReq,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('mergeToCompose', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingPositionStatis.TradeHostingPositionStatis_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingPositionStatis.Client(protocol)
    try:
      transport.open()
      result = client.mergeToCompose(platformArgs,mergeToComposeReq,)
      route_finder.UpdateCallInfo(TradeHostingPositionStatis.TradeHostingPositionStatis_SERVICE_KEY, 'mergeToCompose', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingPositionStatis.TradeHostingPositionStatis_SERVICE_KEY, 'mergeToCompose', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def deleteExpiredStatContractPosition(self, routeKey, timeout, subAccountId,sledContractId,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('deleteExpiredStatContractPosition', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingPositionStatis.TradeHostingPositionStatis_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingPositionStatis.Client(protocol)
    try:
      transport.open()
      result = client.deleteExpiredStatContractPosition(platformArgs,subAccountId,sledContractId,)
      route_finder.UpdateCallInfo(TradeHostingPositionStatis.TradeHostingPositionStatis_SERVICE_KEY, 'deleteExpiredStatContractPosition', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingPositionStatis.TradeHostingPositionStatis_SERVICE_KEY, 'deleteExpiredStatContractPosition', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def queryStatPositionSummaryPage(self, routeKey, timeout, queryOption,pageOption,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('queryStatPositionSummaryPage', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingPositionStatis.TradeHostingPositionStatis_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingPositionStatis.Client(protocol)
    try:
      transport.open()
      result = client.queryStatPositionSummaryPage(platformArgs,queryOption,pageOption,)
      route_finder.UpdateCallInfo(TradeHostingPositionStatis.TradeHostingPositionStatis_SERVICE_KEY, 'queryStatPositionSummaryPage', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingPositionStatis.TradeHostingPositionStatis_SERVICE_KEY, 'queryStatPositionSummaryPage', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def queryStatPositionItemPage(self, routeKey, timeout, queryOption,pageOption,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('queryStatPositionItemPage', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingPositionStatis.TradeHostingPositionStatis_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingPositionStatis.Client(protocol)
    try:
      transport.open()
      result = client.queryStatPositionItemPage(platformArgs,queryOption,pageOption,)
      route_finder.UpdateCallInfo(TradeHostingPositionStatis.TradeHostingPositionStatis_SERVICE_KEY, 'queryStatPositionItemPage', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingPositionStatis.TradeHostingPositionStatis_SERVICE_KEY, 'queryStatPositionItemPage', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def queryCurrentDayStatClosedPositionPage(self, routeKey, timeout, subAccountId,targetKey,targetType,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('queryCurrentDayStatClosedPositionPage', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingPositionStatis.TradeHostingPositionStatis_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingPositionStatis.Client(protocol)
    try:
      transport.open()
      result = client.queryCurrentDayStatClosedPositionPage(platformArgs,subAccountId,targetKey,targetType,)
      route_finder.UpdateCallInfo(TradeHostingPositionStatis.TradeHostingPositionStatis_SERVICE_KEY, 'queryCurrentDayStatClosedPositionPage', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingPositionStatis.TradeHostingPositionStatis_SERVICE_KEY, 'queryCurrentDayStatClosedPositionPage', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def queryStatClosedPositionDetail(self, routeKey, timeout, queryOption,pageOption,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('queryStatClosedPositionDetail', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingPositionStatis.TradeHostingPositionStatis_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingPositionStatis.Client(protocol)
    try:
      transport.open()
      result = client.queryStatClosedPositionDetail(platformArgs,queryOption,pageOption,)
      route_finder.UpdateCallInfo(TradeHostingPositionStatis.TradeHostingPositionStatis_SERVICE_KEY, 'queryStatClosedPositionDetail', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingPositionStatis.TradeHostingPositionStatis_SERVICE_KEY, 'queryStatClosedPositionDetail', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def queryArchivedClosedPositionPage(self, routeKey, timeout, queryOption,pageOption,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('queryArchivedClosedPositionPage', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingPositionStatis.TradeHostingPositionStatis_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingPositionStatis.Client(protocol)
    try:
      transport.open()
      result = client.queryArchivedClosedPositionPage(platformArgs,queryOption,pageOption,)
      route_finder.UpdateCallInfo(TradeHostingPositionStatis.TradeHostingPositionStatis_SERVICE_KEY, 'queryArchivedClosedPositionPage', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingPositionStatis.TradeHostingPositionStatis_SERVICE_KEY, 'queryArchivedClosedPositionPage', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def queryArchivedClosedPositionDetail(self, routeKey, timeout, queryOption,pageOption,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('queryArchivedClosedPositionDetail', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingPositionStatis.TradeHostingPositionStatis_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingPositionStatis.Client(protocol)
    try:
      transport.open()
      result = client.queryArchivedClosedPositionDetail(platformArgs,queryOption,pageOption,)
      route_finder.UpdateCallInfo(TradeHostingPositionStatis.TradeHostingPositionStatis_SERVICE_KEY, 'queryArchivedClosedPositionDetail', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingPositionStatis.TradeHostingPositionStatis_SERVICE_KEY, 'queryArchivedClosedPositionDetail', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def queryStatPositionSummaryExPage(self, routeKey, timeout, queryOption,pageOption,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('queryStatPositionSummaryExPage', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingPositionStatis.TradeHostingPositionStatis_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingPositionStatis.Client(protocol)
    try:
      transport.open()
      result = client.queryStatPositionSummaryExPage(platformArgs,queryOption,pageOption,)
      route_finder.UpdateCallInfo(TradeHostingPositionStatis.TradeHostingPositionStatis_SERVICE_KEY, 'queryStatPositionSummaryExPage', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingPositionStatis.TradeHostingPositionStatis_SERVICE_KEY, 'queryStatPositionSummaryExPage', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def queryStatPositionUnitPage(self, routeKey, timeout, queryOption,pageOption,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('queryStatPositionUnitPage', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingPositionStatis.TradeHostingPositionStatis_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingPositionStatis.Client(protocol)
    try:
      transport.open()
      result = client.queryStatPositionUnitPage(platformArgs,queryOption,pageOption,)
      route_finder.UpdateCallInfo(TradeHostingPositionStatis.TradeHostingPositionStatis_SERVICE_KEY, 'queryStatPositionUnitPage', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingPositionStatis.TradeHostingPositionStatis_SERVICE_KEY, 'queryStatPositionUnitPage', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def queryHistoryClosedPositionPage(self, routeKey, timeout, queryOption,pageOption,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('queryHistoryClosedPositionPage', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingPositionStatis.TradeHostingPositionStatis_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingPositionStatis.Client(protocol)
    try:
      transport.open()
      result = client.queryHistoryClosedPositionPage(platformArgs,queryOption,pageOption,)
      route_finder.UpdateCallInfo(TradeHostingPositionStatis.TradeHostingPositionStatis_SERVICE_KEY, 'queryHistoryClosedPositionPage', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingPositionStatis.TradeHostingPositionStatis_SERVICE_KEY, 'queryHistoryClosedPositionPage', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

  def queryHistoryClosedPositionDetail(self, routeKey, timeout, queryOption,pageOption,):
    platformArgs=PlatformArgs()
    frame = sys._getframe(1)
    code = frame.f_code
    platformArgs.sourceDesc = code.co_filename + '[' + code.co_name + ":" + str(code.co_firstlineno) + ']'
    platformArgs.sourceIp = socket.gethostbyname(socket.getfqdn())
    platformArgs.remoteAddress = self.__getServiceAddr('queryHistoryClosedPositionDetail', routeKey)
    if platformArgs.remoteAddress == None or platformArgs.remoteAddress == '':
      raise Exception('No RouteIp is Found')
    platformArgs.remotePort = 10000 + TradeHostingPositionStatis.TradeHostingPositionStatis_SERVICE_KEY

    transport_socket = TSocket.TSocket(platformArgs.remoteAddress, platformArgs.remotePort)

    transport_socket.setTimeout(timeout)
    transport = TTransport.TFramedTransport(transport_socket)
    protocol = TCompactProtocol.TCompactProtocol(transport)
    client=TradeHostingPositionStatis.Client(protocol)
    try:
      transport.open()
      result = client.queryHistoryClosedPositionDetail(platformArgs,queryOption,pageOption,)
      route_finder.UpdateCallInfo(TradeHostingPositionStatis.TradeHostingPositionStatis_SERVICE_KEY, 'queryHistoryClosedPositionDetail', platformArgs.remoteAddress, 0)
      return result
    except TTransportException,t:
      route_finder.UpdateCallInfo(TradeHostingPositionStatis.TradeHostingPositionStatis_SERVICE_KEY, 'queryHistoryClosedPositionDetail', platformArgs.remoteAddress, 1)
      raise t
    finally:
      transport.close()

