/**
 * Autogenerated by Thrift Compiler (0.9.1)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "contract_types.h"

#include <algorithm>

namespace xueqiao { namespace contract {

int _kCommodityMapFileStatusValues[] = {
  CommodityMapFileStatus::IN_USE,
  CommodityMapFileStatus::NO_USE
};
const char* _kCommodityMapFileStatusNames[] = {
  "IN_USE",
  "NO_USE"
};
const std::map<int, const char*> _CommodityMapFileStatus_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kCommodityMapFileStatusValues, _kCommodityMapFileStatusNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kSyncTaskTypeValues[] = {
  SyncTaskType::COMMODITY,
  SyncTaskType::CONTRACT,
  SyncTaskType::COMMODITY_MAPPING
};
const char* _kSyncTaskTypeNames[] = {
  "COMMODITY",
  "CONTRACT",
  "COMMODITY_MAPPING"
};
const std::map<int, const char*> _SyncTaskType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kSyncTaskTypeValues, _kSyncTaskTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

const char* CommodityMapFileInfo::ascii_fingerprint = "6DD1F7077C76728FAF1012A0C3D2D80B";
const uint8_t CommodityMapFileInfo::binary_fingerprint[16] = {0x6D,0xD1,0xF7,0x07,0x7C,0x76,0x72,0x8F,0xAF,0x10,0x12,0xA0,0xC3,0xD2,0xD8,0x0B};

uint32_t CommodityMapFileInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->commodityMapFile);
          this->__isset.commodityMapFile = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast0;
          xfer += iprot->readI32(ecast0);
          this->techPlatform = ( ::xueqiao::contract::standard::TechPlatform::type)ecast0;
          this->__isset.techPlatform = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->brokerEntryId);
          this->__isset.brokerEntryId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->fileMD5);
          this->__isset.fileMD5 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->path);
          this->__isset.path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->url);
          this->__isset.url = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->version);
          this->__isset.version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->fileInfoId);
          this->__isset.fileInfoId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast1;
          xfer += iprot->readI32(ecast1);
          this->status = (CommodityMapFileStatus::type)ecast1;
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 40:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->createTimestamp);
          this->__isset.createTimestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 41:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lastModityTimestamp);
          this->__isset.lastModityTimestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CommodityMapFileInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CommodityMapFileInfo");

  if (this->__isset.commodityMapFile) {
    xfer += oprot->writeFieldBegin("commodityMapFile", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeBinary(this->commodityMapFile);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.techPlatform) {
    xfer += oprot->writeFieldBegin("techPlatform", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32((int32_t)this->techPlatform);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.brokerEntryId) {
    xfer += oprot->writeFieldBegin("brokerEntryId", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->brokerEntryId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.fileMD5) {
    xfer += oprot->writeFieldBegin("fileMD5", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->fileMD5);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.path) {
    xfer += oprot->writeFieldBegin("path", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->path);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.url) {
    xfer += oprot->writeFieldBegin("url", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->url);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.version) {
    xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_I32, 7);
    xfer += oprot->writeI32(this->version);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.fileInfoId) {
    xfer += oprot->writeFieldBegin("fileInfoId", ::apache::thrift::protocol::T_I32, 8);
    xfer += oprot->writeI32(this->fileInfoId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.status) {
    xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 9);
    xfer += oprot->writeI32((int32_t)this->status);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.createTimestamp) {
    xfer += oprot->writeFieldBegin("createTimestamp", ::apache::thrift::protocol::T_I64, 40);
    xfer += oprot->writeI64(this->createTimestamp);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.lastModityTimestamp) {
    xfer += oprot->writeFieldBegin("lastModityTimestamp", ::apache::thrift::protocol::T_I64, 41);
    xfer += oprot->writeI64(this->lastModityTimestamp);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CommodityMapFileInfo &a, CommodityMapFileInfo &b) {
  using ::std::swap;
  swap(a.commodityMapFile, b.commodityMapFile);
  swap(a.techPlatform, b.techPlatform);
  swap(a.brokerEntryId, b.brokerEntryId);
  swap(a.fileMD5, b.fileMD5);
  swap(a.path, b.path);
  swap(a.url, b.url);
  swap(a.version, b.version);
  swap(a.fileInfoId, b.fileInfoId);
  swap(a.status, b.status);
  swap(a.createTimestamp, b.createTimestamp);
  swap(a.lastModityTimestamp, b.lastModityTimestamp);
  swap(a.__isset, b.__isset);
}

const char* CommodityMapFileInfoPage::ascii_fingerprint = "6D52040EB063DFC3E3F3AE0BBF40ED5F";
const uint8_t CommodityMapFileInfoPage::binary_fingerprint[16] = {0x6D,0x52,0x04,0x0E,0xB0,0x63,0xDF,0xC3,0xE3,0xF3,0xAE,0x0B,0xBF,0x40,0xED,0x5F};

uint32_t CommodityMapFileInfoPage::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->total);
          this->__isset.total = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->page.clear();
            uint32_t _size2;
            ::apache::thrift::protocol::TType _etype5;
            xfer += iprot->readListBegin(_etype5, _size2);
            this->page.resize(_size2);
            uint32_t _i6;
            for (_i6 = 0; _i6 < _size2; ++_i6)
            {
              xfer += this->page[_i6].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.page = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CommodityMapFileInfoPage::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CommodityMapFileInfoPage");

  if (this->__isset.total) {
    xfer += oprot->writeFieldBegin("total", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32(this->total);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.page) {
    xfer += oprot->writeFieldBegin("page", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->page.size()));
      std::vector<CommodityMapFileInfo> ::const_iterator _iter7;
      for (_iter7 = this->page.begin(); _iter7 != this->page.end(); ++_iter7)
      {
        xfer += (*_iter7).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CommodityMapFileInfoPage &a, CommodityMapFileInfoPage &b) {
  using ::std::swap;
  swap(a.total, b.total);
  swap(a.page, b.page);
  swap(a.__isset, b.__isset);
}

const char* ReqCommodityMapFileInfoOption::ascii_fingerprint = "6ADC8564BBFC1EF5E2A6C058B8025040";
const uint8_t ReqCommodityMapFileInfoOption::binary_fingerprint[16] = {0x6A,0xDC,0x85,0x64,0xBB,0xFC,0x1E,0xF5,0xE2,0xA6,0xC0,0x58,0xB8,0x02,0x50,0x40};

uint32_t ReqCommodityMapFileInfoOption::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->brokerEntryIds.clear();
            uint32_t _size8;
            ::apache::thrift::protocol::TType _etype11;
            xfer += iprot->readListBegin(_etype11, _size8);
            this->brokerEntryIds.resize(_size8);
            uint32_t _i12;
            for (_i12 = 0; _i12 < _size8; ++_i12)
            {
              xfer += iprot->readI32(this->brokerEntryIds[_i12]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.brokerEntryIds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast13;
          xfer += iprot->readI32(ecast13);
          this->techPlatform = ( ::xueqiao::contract::standard::TechPlatform::type)ecast13;
          this->__isset.techPlatform = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->fileInfoIds.clear();
            uint32_t _size14;
            ::apache::thrift::protocol::TType _etype17;
            xfer += iprot->readListBegin(_etype17, _size14);
            this->fileInfoIds.resize(_size14);
            uint32_t _i18;
            for (_i18 = 0; _i18 < _size14; ++_i18)
            {
              xfer += iprot->readI32(this->fileInfoIds[_i18]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.fileInfoIds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast19;
          xfer += iprot->readI32(ecast19);
          this->status = (CommodityMapFileStatus::type)ecast19;
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ReqCommodityMapFileInfoOption::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ReqCommodityMapFileInfoOption");

  if (this->__isset.brokerEntryIds) {
    xfer += oprot->writeFieldBegin("brokerEntryIds", ::apache::thrift::protocol::T_LIST, 1);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->brokerEntryIds.size()));
      std::vector<int32_t> ::const_iterator _iter20;
      for (_iter20 = this->brokerEntryIds.begin(); _iter20 != this->brokerEntryIds.end(); ++_iter20)
      {
        xfer += oprot->writeI32((*_iter20));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.techPlatform) {
    xfer += oprot->writeFieldBegin("techPlatform", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32((int32_t)this->techPlatform);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.fileInfoIds) {
    xfer += oprot->writeFieldBegin("fileInfoIds", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->fileInfoIds.size()));
      std::vector<int32_t> ::const_iterator _iter21;
      for (_iter21 = this->fileInfoIds.begin(); _iter21 != this->fileInfoIds.end(); ++_iter21)
      {
        xfer += oprot->writeI32((*_iter21));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.status) {
    xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32((int32_t)this->status);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ReqCommodityMapFileInfoOption &a, ReqCommodityMapFileInfoOption &b) {
  using ::std::swap;
  swap(a.brokerEntryIds, b.brokerEntryIds);
  swap(a.techPlatform, b.techPlatform);
  swap(a.fileInfoIds, b.fileInfoIds);
  swap(a.status, b.status);
  swap(a.__isset, b.__isset);
}

const char* SyncMappingTask::ascii_fingerprint = "60CB21953841BFE052859F6522A32067";
const uint8_t SyncMappingTask::binary_fingerprint[16] = {0x60,0xCB,0x21,0x95,0x38,0x41,0xBF,0xE0,0x52,0x85,0x9F,0x65,0x22,0xA3,0x20,0x67};

uint32_t SyncMappingTask::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->taskId);
          this->__isset.taskId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->syncTargetId);
          this->__isset.syncTargetId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast22;
          xfer += iprot->readI32(ecast22);
          this->techPlatformEnv = ( ::xueqiao::contract::standard::TechPlatformEnv::type)ecast22;
          this->__isset.techPlatformEnv = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast23;
          xfer += iprot->readI32(ecast23);
          this->taskType = (SyncTaskType::type)ecast23;
          this->__isset.taskType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 40:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->createTimestamp);
          this->__isset.createTimestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 41:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lastModityTimestamp);
          this->__isset.lastModityTimestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SyncMappingTask::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SyncMappingTask");

  if (this->__isset.taskId) {
    xfer += oprot->writeFieldBegin("taskId", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32(this->taskId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.syncTargetId) {
    xfer += oprot->writeFieldBegin("syncTargetId", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->syncTargetId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.techPlatformEnv) {
    xfer += oprot->writeFieldBegin("techPlatformEnv", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32((int32_t)this->techPlatformEnv);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.taskType) {
    xfer += oprot->writeFieldBegin("taskType", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32((int32_t)this->taskType);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.createTimestamp) {
    xfer += oprot->writeFieldBegin("createTimestamp", ::apache::thrift::protocol::T_I64, 40);
    xfer += oprot->writeI64(this->createTimestamp);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.lastModityTimestamp) {
    xfer += oprot->writeFieldBegin("lastModityTimestamp", ::apache::thrift::protocol::T_I64, 41);
    xfer += oprot->writeI64(this->lastModityTimestamp);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SyncMappingTask &a, SyncMappingTask &b) {
  using ::std::swap;
  swap(a.taskId, b.taskId);
  swap(a.syncTargetId, b.syncTargetId);
  swap(a.techPlatformEnv, b.techPlatformEnv);
  swap(a.taskType, b.taskType);
  swap(a.createTimestamp, b.createTimestamp);
  swap(a.lastModityTimestamp, b.lastModityTimestamp);
  swap(a.__isset, b.__isset);
}

const char* SyncMappingTaskPage::ascii_fingerprint = "C7F9E0690F9573983EC6F910E2C32D9B";
const uint8_t SyncMappingTaskPage::binary_fingerprint[16] = {0xC7,0xF9,0xE0,0x69,0x0F,0x95,0x73,0x98,0x3E,0xC6,0xF9,0x10,0xE2,0xC3,0x2D,0x9B};

uint32_t SyncMappingTaskPage::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->total);
          this->__isset.total = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->page.clear();
            uint32_t _size24;
            ::apache::thrift::protocol::TType _etype27;
            xfer += iprot->readListBegin(_etype27, _size24);
            this->page.resize(_size24);
            uint32_t _i28;
            for (_i28 = 0; _i28 < _size24; ++_i28)
            {
              xfer += this->page[_i28].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.page = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SyncMappingTaskPage::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SyncMappingTaskPage");

  if (this->__isset.total) {
    xfer += oprot->writeFieldBegin("total", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32(this->total);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.page) {
    xfer += oprot->writeFieldBegin("page", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->page.size()));
      std::vector<SyncMappingTask> ::const_iterator _iter29;
      for (_iter29 = this->page.begin(); _iter29 != this->page.end(); ++_iter29)
      {
        xfer += (*_iter29).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SyncMappingTaskPage &a, SyncMappingTaskPage &b) {
  using ::std::swap;
  swap(a.total, b.total);
  swap(a.page, b.page);
  swap(a.__isset, b.__isset);
}

const char* ReqSyncMappingTaskOption::ascii_fingerprint = "E5B1E9E913FCB9C2DA05C4CB37DFB5AA";
const uint8_t ReqSyncMappingTaskOption::binary_fingerprint[16] = {0xE5,0xB1,0xE9,0xE9,0x13,0xFC,0xB9,0xC2,0xDA,0x05,0xC4,0xCB,0x37,0xDF,0xB5,0xAA};

uint32_t ReqSyncMappingTaskOption::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->taskIds.clear();
            uint32_t _size30;
            ::apache::thrift::protocol::TType _etype33;
            xfer += iprot->readListBegin(_etype33, _size30);
            this->taskIds.resize(_size30);
            uint32_t _i34;
            for (_i34 = 0; _i34 < _size30; ++_i34)
            {
              xfer += iprot->readI32(this->taskIds[_i34]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.taskIds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->targetIds.clear();
            uint32_t _size35;
            ::apache::thrift::protocol::TType _etype38;
            xfer += iprot->readListBegin(_etype38, _size35);
            this->targetIds.resize(_size35);
            uint32_t _i39;
            for (_i39 = 0; _i39 < _size35; ++_i39)
            {
              xfer += iprot->readI32(this->targetIds[_i39]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.targetIds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast40;
          xfer += iprot->readI32(ecast40);
          this->techPlatformEnv = ( ::xueqiao::contract::standard::TechPlatformEnv::type)ecast40;
          this->__isset.techPlatformEnv = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast41;
          xfer += iprot->readI32(ecast41);
          this->taskType = (SyncTaskType::type)ecast41;
          this->__isset.taskType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ReqSyncMappingTaskOption::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ReqSyncMappingTaskOption");

  if (this->__isset.taskIds) {
    xfer += oprot->writeFieldBegin("taskIds", ::apache::thrift::protocol::T_LIST, 1);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->taskIds.size()));
      std::vector<int32_t> ::const_iterator _iter42;
      for (_iter42 = this->taskIds.begin(); _iter42 != this->taskIds.end(); ++_iter42)
      {
        xfer += oprot->writeI32((*_iter42));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.targetIds) {
    xfer += oprot->writeFieldBegin("targetIds", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->targetIds.size()));
      std::vector<int32_t> ::const_iterator _iter43;
      for (_iter43 = this->targetIds.begin(); _iter43 != this->targetIds.end(); ++_iter43)
      {
        xfer += oprot->writeI32((*_iter43));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.techPlatformEnv) {
    xfer += oprot->writeFieldBegin("techPlatformEnv", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32((int32_t)this->techPlatformEnv);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.taskType) {
    xfer += oprot->writeFieldBegin("taskType", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32((int32_t)this->taskType);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ReqSyncMappingTaskOption &a, ReqSyncMappingTaskOption &b) {
  using ::std::swap;
  swap(a.taskIds, b.taskIds);
  swap(a.targetIds, b.targetIds);
  swap(a.techPlatformEnv, b.techPlatformEnv);
  swap(a.taskType, b.taskType);
  swap(a.__isset, b.__isset);
}

const char* TechPlatformCommodity::ascii_fingerprint = "51F49726DC1113A90173E83A03E714D0";
const uint8_t TechPlatformCommodity::binary_fingerprint[16] = {0x51,0xF4,0x97,0x26,0xDC,0x11,0x13,0xA9,0x01,0x73,0xE8,0x3A,0x03,0xE7,0x14,0xD0};

uint32_t TechPlatformCommodity::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->sledCommodityId);
          this->__isset.sledCommodityId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->exchange);
          this->__isset.exchange = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->commodityType);
          this->__isset.commodityType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->commodityCode);
          this->__isset.commodityCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->relateCommodityCodes.clear();
            uint32_t _size44;
            ::apache::thrift::protocol::TType _etype47;
            xfer += iprot->readListBegin(_etype47, _size44);
            this->relateCommodityCodes.resize(_size44);
            uint32_t _i48;
            for (_i48 = 0; _i48 < _size44; ++_i48)
            {
              xfer += iprot->readString(this->relateCommodityCodes[_i48]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.relateCommodityCodes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tradeCurrency);
          this->__isset.tradeCurrency = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->timezone);
          this->__isset.timezone = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->contractSize);
          this->__isset.contractSize = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->tickSize);
          this->__isset.tickSize = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->denominator);
          this->__isset.denominator = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast49;
          xfer += iprot->readI32(ecast49);
          this->cmbDirect = ( ::xueqiao::contract::standard::CmbDirect::type)ecast49;
          this->__isset.cmbDirect = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast50;
          xfer += iprot->readI32(ecast50);
          this->commodityState = ( ::xueqiao::contract::standard::CommodityState::type)ecast50;
          this->__isset.commodityState = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 22:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->engName);
          this->__isset.engName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 23:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cnName);
          this->__isset.cnName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 24:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tcName);
          this->__isset.tcName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast51;
          xfer += iprot->readI32(ecast51);
          this->deliveryMode = ( ::xueqiao::contract::standard::DeliveryMode::type)ecast51;
          this->__isset.deliveryMode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->deliveryDays);
          this->__isset.deliveryDays = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxSingleOrderVol);
          this->__isset.maxSingleOrderVol = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxHoldVol);
          this->__isset.maxHoldVol = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast52;
          xfer += iprot->readI32(ecast52);
          this->commissionCalculateMode = ( ::xueqiao::contract::standard::CalculateMode::type)ecast52;
          this->__isset.commissionCalculateMode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->openCloseFee);
          this->__isset.openCloseFee = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 26:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast53;
          xfer += iprot->readI32(ecast53);
          this->marginCalculateMode = ( ::xueqiao::contract::standard::CalculateMode::type)ecast53;
          this->__isset.marginCalculateMode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 27:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->initialMargin);
          this->__isset.initialMargin = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 28:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->maintenanceMargin);
          this->__isset.maintenanceMargin = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 29:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->sellInitialMargin);
          this->__isset.sellInitialMargin = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->sellMaintenanceMargin);
          this->__isset.sellMaintenanceMargin = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 31:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->lockMargin);
          this->__isset.lockMargin = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 35:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast54;
          xfer += iprot->readI32(ecast54);
          this->techPlatform = ( ::xueqiao::contract::standard::TechPlatform::type)ecast54;
          this->__isset.techPlatform = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 40:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->createTimestamp);
          this->__isset.createTimestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 41:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lastModityTimestamp);
          this->__isset.lastModityTimestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TechPlatformCommodity::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TechPlatformCommodity");

  if (this->__isset.sledCommodityId) {
    xfer += oprot->writeFieldBegin("sledCommodityId", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32(this->sledCommodityId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.exchange) {
    xfer += oprot->writeFieldBegin("exchange", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->exchange);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.commodityType) {
    xfer += oprot->writeFieldBegin("commodityType", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->commodityType);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.commodityCode) {
    xfer += oprot->writeFieldBegin("commodityCode", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->commodityCode);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.relateCommodityCodes) {
    xfer += oprot->writeFieldBegin("relateCommodityCodes", ::apache::thrift::protocol::T_LIST, 5);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->relateCommodityCodes.size()));
      std::vector<std::string> ::const_iterator _iter55;
      for (_iter55 = this->relateCommodityCodes.begin(); _iter55 != this->relateCommodityCodes.end(); ++_iter55)
      {
        xfer += oprot->writeString((*_iter55));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tradeCurrency) {
    xfer += oprot->writeFieldBegin("tradeCurrency", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->tradeCurrency);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.timezone) {
    xfer += oprot->writeFieldBegin("timezone", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->timezone);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.contractSize) {
    xfer += oprot->writeFieldBegin("contractSize", ::apache::thrift::protocol::T_DOUBLE, 8);
    xfer += oprot->writeDouble(this->contractSize);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tickSize) {
    xfer += oprot->writeFieldBegin("tickSize", ::apache::thrift::protocol::T_DOUBLE, 9);
    xfer += oprot->writeDouble(this->tickSize);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.denominator) {
    xfer += oprot->writeFieldBegin("denominator", ::apache::thrift::protocol::T_I32, 10);
    xfer += oprot->writeI32(this->denominator);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cmbDirect) {
    xfer += oprot->writeFieldBegin("cmbDirect", ::apache::thrift::protocol::T_I32, 11);
    xfer += oprot->writeI32((int32_t)this->cmbDirect);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.deliveryMode) {
    xfer += oprot->writeFieldBegin("deliveryMode", ::apache::thrift::protocol::T_I32, 12);
    xfer += oprot->writeI32((int32_t)this->deliveryMode);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.deliveryDays) {
    xfer += oprot->writeFieldBegin("deliveryDays", ::apache::thrift::protocol::T_I32, 13);
    xfer += oprot->writeI32(this->deliveryDays);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.commodityState) {
    xfer += oprot->writeFieldBegin("commodityState", ::apache::thrift::protocol::T_I32, 15);
    xfer += oprot->writeI32((int32_t)this->commodityState);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.maxSingleOrderVol) {
    xfer += oprot->writeFieldBegin("maxSingleOrderVol", ::apache::thrift::protocol::T_I32, 17);
    xfer += oprot->writeI32(this->maxSingleOrderVol);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.maxHoldVol) {
    xfer += oprot->writeFieldBegin("maxHoldVol", ::apache::thrift::protocol::T_I32, 18);
    xfer += oprot->writeI32(this->maxHoldVol);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.commissionCalculateMode) {
    xfer += oprot->writeFieldBegin("commissionCalculateMode", ::apache::thrift::protocol::T_I32, 20);
    xfer += oprot->writeI32((int32_t)this->commissionCalculateMode);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.openCloseFee) {
    xfer += oprot->writeFieldBegin("openCloseFee", ::apache::thrift::protocol::T_DOUBLE, 21);
    xfer += oprot->writeDouble(this->openCloseFee);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.engName) {
    xfer += oprot->writeFieldBegin("engName", ::apache::thrift::protocol::T_STRING, 22);
    xfer += oprot->writeString(this->engName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cnName) {
    xfer += oprot->writeFieldBegin("cnName", ::apache::thrift::protocol::T_STRING, 23);
    xfer += oprot->writeString(this->cnName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tcName) {
    xfer += oprot->writeFieldBegin("tcName", ::apache::thrift::protocol::T_STRING, 24);
    xfer += oprot->writeString(this->tcName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.marginCalculateMode) {
    xfer += oprot->writeFieldBegin("marginCalculateMode", ::apache::thrift::protocol::T_I32, 26);
    xfer += oprot->writeI32((int32_t)this->marginCalculateMode);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.initialMargin) {
    xfer += oprot->writeFieldBegin("initialMargin", ::apache::thrift::protocol::T_DOUBLE, 27);
    xfer += oprot->writeDouble(this->initialMargin);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.maintenanceMargin) {
    xfer += oprot->writeFieldBegin("maintenanceMargin", ::apache::thrift::protocol::T_DOUBLE, 28);
    xfer += oprot->writeDouble(this->maintenanceMargin);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.sellInitialMargin) {
    xfer += oprot->writeFieldBegin("sellInitialMargin", ::apache::thrift::protocol::T_DOUBLE, 29);
    xfer += oprot->writeDouble(this->sellInitialMargin);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.sellMaintenanceMargin) {
    xfer += oprot->writeFieldBegin("sellMaintenanceMargin", ::apache::thrift::protocol::T_DOUBLE, 30);
    xfer += oprot->writeDouble(this->sellMaintenanceMargin);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.lockMargin) {
    xfer += oprot->writeFieldBegin("lockMargin", ::apache::thrift::protocol::T_DOUBLE, 31);
    xfer += oprot->writeDouble(this->lockMargin);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.techPlatform) {
    xfer += oprot->writeFieldBegin("techPlatform", ::apache::thrift::protocol::T_I32, 35);
    xfer += oprot->writeI32((int32_t)this->techPlatform);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.createTimestamp) {
    xfer += oprot->writeFieldBegin("createTimestamp", ::apache::thrift::protocol::T_I64, 40);
    xfer += oprot->writeI64(this->createTimestamp);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.lastModityTimestamp) {
    xfer += oprot->writeFieldBegin("lastModityTimestamp", ::apache::thrift::protocol::T_I64, 41);
    xfer += oprot->writeI64(this->lastModityTimestamp);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TechPlatformCommodity &a, TechPlatformCommodity &b) {
  using ::std::swap;
  swap(a.sledCommodityId, b.sledCommodityId);
  swap(a.exchange, b.exchange);
  swap(a.commodityType, b.commodityType);
  swap(a.commodityCode, b.commodityCode);
  swap(a.relateCommodityCodes, b.relateCommodityCodes);
  swap(a.tradeCurrency, b.tradeCurrency);
  swap(a.timezone, b.timezone);
  swap(a.contractSize, b.contractSize);
  swap(a.tickSize, b.tickSize);
  swap(a.denominator, b.denominator);
  swap(a.cmbDirect, b.cmbDirect);
  swap(a.commodityState, b.commodityState);
  swap(a.engName, b.engName);
  swap(a.cnName, b.cnName);
  swap(a.tcName, b.tcName);
  swap(a.deliveryMode, b.deliveryMode);
  swap(a.deliveryDays, b.deliveryDays);
  swap(a.maxSingleOrderVol, b.maxSingleOrderVol);
  swap(a.maxHoldVol, b.maxHoldVol);
  swap(a.commissionCalculateMode, b.commissionCalculateMode);
  swap(a.openCloseFee, b.openCloseFee);
  swap(a.marginCalculateMode, b.marginCalculateMode);
  swap(a.initialMargin, b.initialMargin);
  swap(a.maintenanceMargin, b.maintenanceMargin);
  swap(a.sellInitialMargin, b.sellInitialMargin);
  swap(a.sellMaintenanceMargin, b.sellMaintenanceMargin);
  swap(a.lockMargin, b.lockMargin);
  swap(a.techPlatform, b.techPlatform);
  swap(a.createTimestamp, b.createTimestamp);
  swap(a.lastModityTimestamp, b.lastModityTimestamp);
  swap(a.__isset, b.__isset);
}

const char* TechPlatformCommodityPage::ascii_fingerprint = "75D62B2BD37805774DD0784B31047437";
const uint8_t TechPlatformCommodityPage::binary_fingerprint[16] = {0x75,0xD6,0x2B,0x2B,0xD3,0x78,0x05,0x77,0x4D,0xD0,0x78,0x4B,0x31,0x04,0x74,0x37};

uint32_t TechPlatformCommodityPage::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->total);
          this->__isset.total = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->page.clear();
            uint32_t _size56;
            ::apache::thrift::protocol::TType _etype59;
            xfer += iprot->readListBegin(_etype59, _size56);
            this->page.resize(_size56);
            uint32_t _i60;
            for (_i60 = 0; _i60 < _size56; ++_i60)
            {
              xfer += this->page[_i60].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.page = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TechPlatformCommodityPage::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TechPlatformCommodityPage");

  if (this->__isset.total) {
    xfer += oprot->writeFieldBegin("total", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32(this->total);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.page) {
    xfer += oprot->writeFieldBegin("page", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->page.size()));
      std::vector<TechPlatformCommodity> ::const_iterator _iter61;
      for (_iter61 = this->page.begin(); _iter61 != this->page.end(); ++_iter61)
      {
        xfer += (*_iter61).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TechPlatformCommodityPage &a, TechPlatformCommodityPage &b) {
  using ::std::swap;
  swap(a.total, b.total);
  swap(a.page, b.page);
  swap(a.__isset, b.__isset);
}

const char* ReqTechPlatformCommodityOption::ascii_fingerprint = "315534714801362F91C396FE09ADBFCE";
const uint8_t ReqTechPlatformCommodityOption::binary_fingerprint[16] = {0x31,0x55,0x34,0x71,0x48,0x01,0x36,0x2F,0x91,0xC3,0x96,0xFE,0x09,0xAD,0xBF,0xCE};

uint32_t ReqTechPlatformCommodityOption::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->techPlatformCommodityIds.clear();
            uint32_t _size62;
            ::apache::thrift::protocol::TType _etype65;
            xfer += iprot->readListBegin(_etype65, _size62);
            this->techPlatformCommodityIds.resize(_size62);
            uint32_t _i66;
            for (_i66 = 0; _i66 < _size62; ++_i66)
            {
              xfer += iprot->readI32(this->techPlatformCommodityIds[_i66]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.techPlatformCommodityIds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->sledCommodityIds.clear();
            uint32_t _size67;
            ::apache::thrift::protocol::TType _etype70;
            xfer += iprot->readListBegin(_etype70, _size67);
            this->sledCommodityIds.resize(_size67);
            uint32_t _i71;
            for (_i71 = 0; _i71 < _size67; ++_i71)
            {
              xfer += iprot->readI32(this->sledCommodityIds[_i71]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.sledCommodityIds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast72;
          xfer += iprot->readI32(ecast72);
          this->techPlatform = ( ::xueqiao::contract::standard::TechPlatform::type)ecast72;
          this->__isset.techPlatform = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ReqTechPlatformCommodityOption::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ReqTechPlatformCommodityOption");

  if (this->__isset.techPlatformCommodityIds) {
    xfer += oprot->writeFieldBegin("techPlatformCommodityIds", ::apache::thrift::protocol::T_LIST, 1);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->techPlatformCommodityIds.size()));
      std::vector<int32_t> ::const_iterator _iter73;
      for (_iter73 = this->techPlatformCommodityIds.begin(); _iter73 != this->techPlatformCommodityIds.end(); ++_iter73)
      {
        xfer += oprot->writeI32((*_iter73));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.sledCommodityIds) {
    xfer += oprot->writeFieldBegin("sledCommodityIds", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->sledCommodityIds.size()));
      std::vector<int32_t> ::const_iterator _iter74;
      for (_iter74 = this->sledCommodityIds.begin(); _iter74 != this->sledCommodityIds.end(); ++_iter74)
      {
        xfer += oprot->writeI32((*_iter74));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.techPlatform) {
    xfer += oprot->writeFieldBegin("techPlatform", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32((int32_t)this->techPlatform);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ReqTechPlatformCommodityOption &a, ReqTechPlatformCommodityOption &b) {
  using ::std::swap;
  swap(a.techPlatformCommodityIds, b.techPlatformCommodityIds);
  swap(a.sledCommodityIds, b.sledCommodityIds);
  swap(a.techPlatform, b.techPlatform);
  swap(a.__isset, b.__isset);
}

const char* ContractVersion::ascii_fingerprint = "4D797E018594391851F591D6C0C06F31";
const uint8_t ContractVersion::binary_fingerprint[16] = {0x4D,0x79,0x7E,0x01,0x85,0x94,0x39,0x18,0x51,0xF5,0x91,0xD6,0xC0,0xC0,0x6F,0x31};

uint32_t ContractVersion::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->versionId);
          this->__isset.versionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->fileMD5);
          this->__isset.fileMD5 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->filePath);
          this->__isset.filePath = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->createTimestamp);
          this->__isset.createTimestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lastModityTimestamp);
          this->__isset.lastModityTimestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ContractVersion::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ContractVersion");

  if (this->__isset.versionId) {
    xfer += oprot->writeFieldBegin("versionId", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32(this->versionId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.fileMD5) {
    xfer += oprot->writeFieldBegin("fileMD5", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->fileMD5);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.filePath) {
    xfer += oprot->writeFieldBegin("filePath", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->filePath);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.createTimestamp) {
    xfer += oprot->writeFieldBegin("createTimestamp", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->createTimestamp);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.lastModityTimestamp) {
    xfer += oprot->writeFieldBegin("lastModityTimestamp", ::apache::thrift::protocol::T_I64, 5);
    xfer += oprot->writeI64(this->lastModityTimestamp);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ContractVersion &a, ContractVersion &b) {
  using ::std::swap;
  swap(a.versionId, b.versionId);
  swap(a.fileMD5, b.fileMD5);
  swap(a.filePath, b.filePath);
  swap(a.createTimestamp, b.createTimestamp);
  swap(a.lastModityTimestamp, b.lastModityTimestamp);
  swap(a.__isset, b.__isset);
}

const char* ContractVersionPage::ascii_fingerprint = "01913D4C8789EDA492129FF11D48883B";
const uint8_t ContractVersionPage::binary_fingerprint[16] = {0x01,0x91,0x3D,0x4C,0x87,0x89,0xED,0xA4,0x92,0x12,0x9F,0xF1,0x1D,0x48,0x88,0x3B};

uint32_t ContractVersionPage::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->total);
          this->__isset.total = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->page.clear();
            uint32_t _size75;
            ::apache::thrift::protocol::TType _etype78;
            xfer += iprot->readListBegin(_etype78, _size75);
            this->page.resize(_size75);
            uint32_t _i79;
            for (_i79 = 0; _i79 < _size75; ++_i79)
            {
              xfer += this->page[_i79].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.page = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ContractVersionPage::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ContractVersionPage");

  if (this->__isset.total) {
    xfer += oprot->writeFieldBegin("total", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32(this->total);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.page) {
    xfer += oprot->writeFieldBegin("page", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->page.size()));
      std::vector<ContractVersion> ::const_iterator _iter80;
      for (_iter80 = this->page.begin(); _iter80 != this->page.end(); ++_iter80)
      {
        xfer += (*_iter80).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ContractVersionPage &a, ContractVersionPage &b) {
  using ::std::swap;
  swap(a.total, b.total);
  swap(a.page, b.page);
  swap(a.__isset, b.__isset);
}

const char* ReqContractVersionOption::ascii_fingerprint = "66B98FA31E5D1C70A3C9D6A8C5E65F30";
const uint8_t ReqContractVersionOption::binary_fingerprint[16] = {0x66,0xB9,0x8F,0xA3,0x1E,0x5D,0x1C,0x70,0xA3,0xC9,0xD6,0xA8,0xC5,0xE6,0x5F,0x30};

uint32_t ReqContractVersionOption::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->versionId);
          this->__isset.versionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->latest);
          this->__isset.latest = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ReqContractVersionOption::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ReqContractVersionOption");

  if (this->__isset.versionId) {
    xfer += oprot->writeFieldBegin("versionId", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32(this->versionId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.latest) {
    xfer += oprot->writeFieldBegin("latest", ::apache::thrift::protocol::T_BOOL, 2);
    xfer += oprot->writeBool(this->latest);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ReqContractVersionOption &a, ReqContractVersionOption &b) {
  using ::std::swap;
  swap(a.versionId, b.versionId);
  swap(a.latest, b.latest);
  swap(a.__isset, b.__isset);
}

const char* RemoveContractVersionOption::ascii_fingerprint = "66B98FA31E5D1C70A3C9D6A8C5E65F30";
const uint8_t RemoveContractVersionOption::binary_fingerprint[16] = {0x66,0xB9,0x8F,0xA3,0x1E,0x5D,0x1C,0x70,0xA3,0xC9,0xD6,0xA8,0xC5,0xE6,0x5F,0x30};

uint32_t RemoveContractVersionOption::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->versionId);
          this->__isset.versionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->all);
          this->__isset.all = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t RemoveContractVersionOption::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("RemoveContractVersionOption");

  if (this->__isset.versionId) {
    xfer += oprot->writeFieldBegin("versionId", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32(this->versionId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.all) {
    xfer += oprot->writeFieldBegin("all", ::apache::thrift::protocol::T_BOOL, 2);
    xfer += oprot->writeBool(this->all);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RemoveContractVersionOption &a, RemoveContractVersionOption &b) {
  using ::std::swap;
  swap(a.versionId, b.versionId);
  swap(a.all, b.all);
  swap(a.__isset, b.__isset);
}

const char* DbLockingInfo::ascii_fingerprint = "912BF9B953A764D3D0E7B602BC112821";
const uint8_t DbLockingInfo::binary_fingerprint[16] = {0x91,0x2B,0xF9,0xB9,0x53,0xA7,0x64,0xD3,0xD0,0xE7,0xB6,0x02,0xBC,0x11,0x28,0x21};

uint32_t DbLockingInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isLocked);
          this->__isset.isLocked = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->lockedBy);
          this->__isset.lockedBy = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->startLockedTimestamp);
          this->__isset.startLockedTimestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->createTimestamp);
          this->__isset.createTimestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->lockArea);
          this->__isset.lockArea = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DbLockingInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("DbLockingInfo");

  if (this->__isset.isLocked) {
    xfer += oprot->writeFieldBegin("isLocked", ::apache::thrift::protocol::T_BOOL, 1);
    xfer += oprot->writeBool(this->isLocked);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.lockedBy) {
    xfer += oprot->writeFieldBegin("lockedBy", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->lockedBy);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.startLockedTimestamp) {
    xfer += oprot->writeFieldBegin("startLockedTimestamp", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->startLockedTimestamp);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.createTimestamp) {
    xfer += oprot->writeFieldBegin("createTimestamp", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->createTimestamp);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.lockArea) {
    xfer += oprot->writeFieldBegin("lockArea", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->lockArea);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DbLockingInfo &a, DbLockingInfo &b) {
  using ::std::swap;
  swap(a.isLocked, b.isLocked);
  swap(a.lockedBy, b.lockedBy);
  swap(a.startLockedTimestamp, b.startLockedTimestamp);
  swap(a.createTimestamp, b.createTimestamp);
  swap(a.lockArea, b.lockArea);
  swap(a.__isset, b.__isset);
}

}} // namespace
