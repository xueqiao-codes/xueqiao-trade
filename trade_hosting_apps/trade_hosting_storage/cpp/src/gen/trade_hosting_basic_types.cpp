/**
 * Autogenerated by Thrift Compiler (0.9.1)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "trade_hosting_basic_types.h"

#include <algorithm>

namespace xueqiao { namespace trade { namespace hosting {

int _kHostingStatusValues[] = {
  HostingStatus::EMPTY,
  HostingStatus::NORMAL,
  HostingStatus::CLEARING
};
const char* _kHostingStatusNames[] = {
  "EMPTY",
  "NORMAL",
  "CLEARING"
};
const std::map<int, const char*> _HostingStatus_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kHostingStatusValues, _kHostingStatusNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kHostingRunningModeValues[] = {
  HostingRunningMode::ALLDAY_HOSTING,
  HostingRunningMode::SIM_HOSTING,
  HostingRunningMode::REAL_HOSTING
};
const char* _kHostingRunningModeNames[] = {
  "ALLDAY_HOSTING",
  "SIM_HOSTING",
  "REAL_HOSTING"
};
const std::map<int, const char*> _HostingRunningMode_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kHostingRunningModeValues, _kHostingRunningModeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kEHostingUserRoleValues[] = {
  EHostingUserRole::AdminGroup,
  EHostingUserRole::BossGroup,
  EHostingUserRole::TraderGroup
};
const char* _kEHostingUserRoleNames[] = {
  "AdminGroup",
  "BossGroup",
  "TraderGroup"
};
const std::map<int, const char*> _EHostingUserRole_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kEHostingUserRoleValues, _kEHostingUserRoleNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kHostingUserOrderTypeValues[] = {
  HostingUserOrderType::OrderByCreateTimestampAsc,
  HostingUserOrderType::OrderByCreateTimestampDesc,
  HostingUserOrderType::OrderByLoginNameAsc,
  HostingUserOrderType::OrderByLoginNameDesc
};
const char* _kHostingUserOrderTypeNames[] = {
  "OrderByCreateTimestampAsc",
  "OrderByCreateTimestampDesc",
  "OrderByLoginNameAsc",
  "OrderByLoginNameDesc"
};
const std::map<int, const char*> _HostingUserOrderType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kHostingUserOrderTypeValues, _kHostingUserOrderTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kHostingUserStateValues[] = {
  HostingUserState::USER_NORMAL,
  HostingUserState::USER_DISABLED
};
const char* _kHostingUserStateNames[] = {
  "USER_NORMAL",
  "USER_DISABLED"
};
const std::map<int, const char*> _HostingUserState_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kHostingUserStateValues, _kHostingUserStateNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kHostingComposeLegTradeDirectionValues[] = {
  HostingComposeLegTradeDirection::COMPOSE_LEG_BUY,
  HostingComposeLegTradeDirection::COMPOSE_LEG_SELL
};
const char* _kHostingComposeLegTradeDirectionNames[] = {
  "COMPOSE_LEG_BUY",
  "COMPOSE_LEG_SELL"
};
const std::map<int, const char*> _HostingComposeLegTradeDirection_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kHostingComposeLegTradeDirectionValues, _kHostingComposeLegTradeDirectionNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kHostingComposeGraphEnvValues[] = {
  HostingComposeGraphEnv::COMPOSE_GRAPH_SIM,
  HostingComposeGraphEnv::COMPOSE_GRAPH_REAL
};
const char* _kHostingComposeGraphEnvNames[] = {
  "COMPOSE_GRAPH_SIM",
  "COMPOSE_GRAPH_REAL"
};
const std::map<int, const char*> _HostingComposeGraphEnv_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kHostingComposeGraphEnvValues, _kHostingComposeGraphEnvNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kHostingComposeViewSourceValues[] = {
  HostingComposeViewSource::USER_CREATED,
  HostingComposeViewSource::USER_SEARCHED
};
const char* _kHostingComposeViewSourceNames[] = {
  "USER_CREATED",
  "USER_SEARCHED"
};
const std::map<int, const char*> _HostingComposeViewSource_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kHostingComposeViewSourceValues, _kHostingComposeViewSourceNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kHostingComposeViewSubscribeStatusValues[] = {
  HostingComposeViewSubscribeStatus::UNSUBSCRIBED,
  HostingComposeViewSubscribeStatus::SUBSCRIBED
};
const char* _kHostingComposeViewSubscribeStatusNames[] = {
  "UNSUBSCRIBED",
  "SUBSCRIBED"
};
const std::map<int, const char*> _HostingComposeViewSubscribeStatus_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kHostingComposeViewSubscribeStatusValues, _kHostingComposeViewSubscribeStatusNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kBrokerTechPlatformValues[] = {
  BrokerTechPlatform::TECH_CTP,
  BrokerTechPlatform::TECH_ESUNNY_9,
  BrokerTechPlatform::TECH_ESUNNY_3
};
const char* _kBrokerTechPlatformNames[] = {
  "TECH_CTP",
  "TECH_ESUNNY_9",
  "TECH_ESUNNY_3"
};
const std::map<int, const char*> _BrokerTechPlatform_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kBrokerTechPlatformValues, _kBrokerTechPlatformNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTradeAccountStateValues[] = {
  TradeAccountState::ACCOUNT_NORMAL,
  TradeAccountState::ACCOUNT_REMOVED,
  TradeAccountState::ACCOUNT_DISABLED
};
const char* _kTradeAccountStateNames[] = {
  "ACCOUNT_NORMAL",
  "ACCOUNT_REMOVED",
  "ACCOUNT_DISABLED"
};
const std::map<int, const char*> _TradeAccountState_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kTradeAccountStateValues, _kTradeAccountStateNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTradeAccountAccessStateValues[] = {
  TradeAccountAccessState::ACCOUNT_ACTIVE,
  TradeAccountAccessState::ACCOUNT_INVALID
};
const char* _kTradeAccountAccessStateNames[] = {
  "ACCOUNT_ACTIVE",
  "ACCOUNT_INVALID"
};
const std::map<int, const char*> _TradeAccountAccessState_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kTradeAccountAccessStateValues, _kTradeAccountAccessStateNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kHostingExecOrderTypeValues[] = {
  HostingExecOrderType::ORDER_LIMIT_PRICE,
  HostingExecOrderType::ORDER_WITH_CONDITION
};
const char* _kHostingExecOrderTypeNames[] = {
  "ORDER_LIMIT_PRICE",
  "ORDER_WITH_CONDITION"
};
const std::map<int, const char*> _HostingExecOrderType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kHostingExecOrderTypeValues, _kHostingExecOrderTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kHostingExecOrderTradeDirectionValues[] = {
  HostingExecOrderTradeDirection::ORDER_BUY,
  HostingExecOrderTradeDirection::ORDER_SELL
};
const char* _kHostingExecOrderTradeDirectionNames[] = {
  "ORDER_BUY",
  "ORDER_SELL"
};
const std::map<int, const char*> _HostingExecOrderTradeDirection_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kHostingExecOrderTradeDirectionValues, _kHostingExecOrderTradeDirectionNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kHostingExecOrderCreatorTypeValues[] = {
  HostingExecOrderCreatorType::ORDER_ARTIFICAL,
  HostingExecOrderCreatorType::ORDER_MACHINE
};
const char* _kHostingExecOrderCreatorTypeNames[] = {
  "ORDER_ARTIFICAL",
  "ORDER_MACHINE"
};
const std::map<int, const char*> _HostingExecOrderCreatorType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kHostingExecOrderCreatorTypeValues, _kHostingExecOrderCreatorTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kHostingExecOrderModeValues[] = {
  HostingExecOrderMode::ORDER_FOK,
  HostingExecOrderMode::ORDER_FAK,
  HostingExecOrderMode::ORDER_GFD,
  HostingExecOrderMode::ORDER_GTC,
  HostingExecOrderMode::ORDER_GTD
};
const char* _kHostingExecOrderModeNames[] = {
  "ORDER_FOK",
  "ORDER_FAK",
  "ORDER_GFD",
  "ORDER_GTC",
  "ORDER_GTD"
};
const std::map<int, const char*> _HostingExecOrderMode_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kHostingExecOrderModeValues, _kHostingExecOrderModeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kHostingExecOrderConditionValues[] = {
  HostingExecOrderCondition::LASTEST_PRICE_GT,
  HostingExecOrderCondition::LASTEST_PRICE_GE,
  HostingExecOrderCondition::LASTEST_PRICE_LT,
  HostingExecOrderCondition::LASTEST_PRICE_LE,
  HostingExecOrderCondition::SELLONE_PRICE_GT,
  HostingExecOrderCondition::SELLONE_PRICE_GE,
  HostingExecOrderCondition::SELLONE_PRICE_LT,
  HostingExecOrderCondition::SELLONE_PRICE_LE,
  HostingExecOrderCondition::BUYONE_PRICE_GT,
  HostingExecOrderCondition::BUYONE_PRICE_GE,
  HostingExecOrderCondition::BUYONE_PRICE_LT,
  HostingExecOrderCondition::BUYONE_PRICE_LE
};
const char* _kHostingExecOrderConditionNames[] = {
  "LASTEST_PRICE_GT",
  "LASTEST_PRICE_GE",
  "LASTEST_PRICE_LT",
  "LASTEST_PRICE_LE",
  "SELLONE_PRICE_GT",
  "SELLONE_PRICE_GE",
  "SELLONE_PRICE_LT",
  "SELLONE_PRICE_LE",
  "BUYONE_PRICE_GT",
  "BUYONE_PRICE_GE",
  "BUYONE_PRICE_LT",
  "BUYONE_PRICE_LE"
};
const std::map<int, const char*> _HostingExecOrderCondition_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(12, _kHostingExecOrderConditionValues, _kHostingExecOrderConditionNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kHostingExecOrderStateValueValues[] = {
  HostingExecOrderStateValue::ORDER_WAITING_VERIFY,
  HostingExecOrderStateValue::ORDER_VERIFY_FAILED,
  HostingExecOrderStateValue::ORDER_WAITING_SLED_SEND,
  HostingExecOrderStateValue::ORDER_SLED_SEND_FAILED,
  HostingExecOrderStateValue::ORDER_SLED_SEND_UNKOWN,
  HostingExecOrderStateValue::ORDER_UPSIDE_REJECTED,
  HostingExecOrderStateValue::ORDER_UPSIDE_RECEIVED,
  HostingExecOrderStateValue::ORDER_UPSIDE_RESTING,
  HostingExecOrderStateValue::ORDER_UPSIDE_PARTFINISHED,
  HostingExecOrderStateValue::ORDER_UPSIDE_FINISHED,
  HostingExecOrderStateValue::ORDER_UPSIDE_RECEIVED_WAITING_REVOKE,
  HostingExecOrderStateValue::ORDER_UPSIDE_RESTING_WAITING_REVOKE,
  HostingExecOrderStateValue::ORDER_UPSIDE_PARTFINISHED_WAITING_REVOKE,
  HostingExecOrderStateValue::ORDER_UPSIDE_RECEIVED_REVOKE_SEND_UNKOWN,
  HostingExecOrderStateValue::ORDER_UPSIDE_RESTING_REVOKE_SEND_UNKOWN,
  HostingExecOrderStateValue::ORDER_UPSIDE_PARTFINISHED_REVOKE_SEND_UNKOWN,
  HostingExecOrderStateValue::ORDER_UPSIDE_REVOKE_RECEIVED,
  HostingExecOrderStateValue::ORDER_UPSIDE_DELETED,
  HostingExecOrderStateValue::ORDER_CONDITION_NOT_TRIGGER,
  HostingExecOrderStateValue::ORDER_CONDITION_TRIGGEDED,
  HostingExecOrderStateValue::ORDER_CONDITION_NOT_TRIGGER_WAITING_REVOKE,
  HostingExecOrderStateValue::ORDER_CONDITION_NOT_TRIGGER_REVOKE_SEND_UNKOWN,
  HostingExecOrderStateValue::ORDER_SLED_ALLOC_REF_FINISHED,
  HostingExecOrderStateValue::ORDER_EXPIRED
};
const char* _kHostingExecOrderStateValueNames[] = {
  "ORDER_WAITING_VERIFY",
  "ORDER_VERIFY_FAILED",
  "ORDER_WAITING_SLED_SEND",
  "ORDER_SLED_SEND_FAILED",
  "ORDER_SLED_SEND_UNKOWN",
  "ORDER_UPSIDE_REJECTED",
  "ORDER_UPSIDE_RECEIVED",
  "ORDER_UPSIDE_RESTING",
  "ORDER_UPSIDE_PARTFINISHED",
  "ORDER_UPSIDE_FINISHED",
  "ORDER_UPSIDE_RECEIVED_WAITING_REVOKE",
  "ORDER_UPSIDE_RESTING_WAITING_REVOKE",
  "ORDER_UPSIDE_PARTFINISHED_WAITING_REVOKE",
  "ORDER_UPSIDE_RECEIVED_REVOKE_SEND_UNKOWN",
  "ORDER_UPSIDE_RESTING_REVOKE_SEND_UNKOWN",
  "ORDER_UPSIDE_PARTFINISHED_REVOKE_SEND_UNKOWN",
  "ORDER_UPSIDE_REVOKE_RECEIVED",
  "ORDER_UPSIDE_DELETED",
  "ORDER_CONDITION_NOT_TRIGGER",
  "ORDER_CONDITION_TRIGGEDED",
  "ORDER_CONDITION_NOT_TRIGGER_WAITING_REVOKE",
  "ORDER_CONDITION_NOT_TRIGGER_REVOKE_SEND_UNKOWN",
  "ORDER_SLED_ALLOC_REF_FINISHED",
  "ORDER_EXPIRED"
};
const std::map<int, const char*> _HostingExecOrderStateValue_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(24, _kHostingExecOrderStateValueValues, _kHostingExecOrderStateValueNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kCTPCombOffsetFlagTypeValues[] = {
  CTPCombOffsetFlagType::THOST_FTDC_OF_OPEN,
  CTPCombOffsetFlagType::THOST_FTDC_OF_ClOSE,
  CTPCombOffsetFlagType::THOST_FTDC_OF_FORCECLOSE,
  CTPCombOffsetFlagType::THOST_FTDC_OF_CLOSETODAY,
  CTPCombOffsetFlagType::THOST_FTDC_OF_CLOSEYESTERDAY,
  CTPCombOffsetFlagType::THOST_FTDC_OF_LOCALFORCECLOSE
};
const char* _kCTPCombOffsetFlagTypeNames[] = {
  "THOST_FTDC_OF_OPEN",
  "THOST_FTDC_OF_ClOSE",
  "THOST_FTDC_OF_FORCECLOSE",
  "THOST_FTDC_OF_CLOSETODAY",
  "THOST_FTDC_OF_CLOSEYESTERDAY",
  "THOST_FTDC_OF_LOCALFORCECLOSE"
};
const std::map<int, const char*> _CTPCombOffsetFlagType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _kCTPCombOffsetFlagTypeValues, _kCTPCombOffsetFlagTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kCTPCombHedgeFlagTypeValues[] = {
  CTPCombHedgeFlagType::THOST_FTDC_HF_SPECULATION,
  CTPCombHedgeFlagType::THOST_FTDC_HF_ARBITRAGE,
  CTPCombHedgeFlagType::THOST_FTDC_HF_HEDGE,
  CTPCombHedgeFlagType::THOST_FTDC_HF_MARKETMAKER
};
const char* _kCTPCombHedgeFlagTypeNames[] = {
  "THOST_FTDC_HF_SPECULATION",
  "THOST_FTDC_HF_ARBITRAGE",
  "THOST_FTDC_HF_HEDGE",
  "THOST_FTDC_HF_MARKETMAKER"
};
const std::map<int, const char*> _CTPCombHedgeFlagType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kCTPCombHedgeFlagTypeValues, _kCTPCombHedgeFlagTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kCTPTradeDirectionValues[] = {
  CTPTradeDirection::CTP_BUY,
  CTPTradeDirection::CTP_SELL
};
const char* _kCTPTradeDirectionNames[] = {
  "CTP_BUY",
  "CTP_SELL"
};
const std::map<int, const char*> _CTPTradeDirection_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kCTPTradeDirectionValues, _kCTPTradeDirectionNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kHostingUpsideNotifyStateTypeValues[] = {
  HostingUpsideNotifyStateType::NOTIFY_UPSIDE_RECIVED,
  HostingUpsideNotifyStateType::NOTIFY_CONDITION_NOT_TRIGGERED,
  HostingUpsideNotifyStateType::NOTIFY_CONDITION_TRIGGERED,
  HostingUpsideNotifyStateType::NOTIFY_ORDER_RESTING,
  HostingUpsideNotifyStateType::NOTIFY_ORDER_CANCELLED,
  HostingUpsideNotifyStateType::NOTIFY_ORDER_PARTFINISHED,
  HostingUpsideNotifyStateType::NOTIFY_ORDER_FINISHED,
  HostingUpsideNotifyStateType::NOTIFY_ORDER_REJECTED,
  HostingUpsideNotifyStateType::NOTIFY_ORDER_CANCEL_RECEIVED
};
const char* _kHostingUpsideNotifyStateTypeNames[] = {
  "NOTIFY_UPSIDE_RECIVED",
  "NOTIFY_CONDITION_NOT_TRIGGERED",
  "NOTIFY_CONDITION_TRIGGERED",
  "NOTIFY_ORDER_RESTING",
  "NOTIFY_ORDER_CANCELLED",
  "NOTIFY_ORDER_PARTFINISHED",
  "NOTIFY_ORDER_FINISHED",
  "NOTIFY_ORDER_REJECTED",
  "NOTIFY_ORDER_CANCEL_RECEIVED"
};
const std::map<int, const char*> _HostingUpsideNotifyStateType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(9, _kHostingUpsideNotifyStateTypeValues, _kHostingUpsideNotifyStateTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kHostingUpsideNotifyStateSourceValues[] = {
  HostingUpsideNotifyStateSource::UPSIDE_FORWARD,
  HostingUpsideNotifyStateSource::UPSIDE_SYNC
};
const char* _kHostingUpsideNotifyStateSourceNames[] = {
  "UPSIDE_FORWARD",
  "UPSIDE_SYNC"
};
const std::map<int, const char*> _HostingUpsideNotifyStateSource_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kHostingUpsideNotifyStateSourceValues, _kHostingUpsideNotifyStateSourceNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kHostingExecTradeDirectionValues[] = {
  HostingExecTradeDirection::TRADE_BUY,
  HostingExecTradeDirection::TRADE_SELL
};
const char* _kHostingExecTradeDirectionNames[] = {
  "TRADE_BUY",
  "TRADE_SELL"
};
const std::map<int, const char*> _HostingExecTradeDirection_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kHostingExecTradeDirectionValues, _kHostingExecTradeDirectionNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

const char* HostingInfo::ascii_fingerprint = "EA9CFD2EF4EE92CDD08BA734313E42AE";
const uint8_t HostingInfo::binary_fingerprint[16] = {0xEA,0x9C,0xFD,0x2E,0xF4,0xEE,0x92,0xCD,0xD0,0x8B,0xA7,0x34,0x31,0x3E,0x42,0xAE};

uint32_t HostingInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast0;
          xfer += iprot->readI32(ecast0);
          this->status = (HostingStatus::type)ecast0;
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->tableVersion);
          this->__isset.tableVersion = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->subUserTotalCount);
          this->__isset.subUserTotalCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->composeTotalCount);
          this->__isset.composeTotalCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->onlineUserTotalCount);
          this->__isset.onlineUserTotalCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->machineId);
          this->__isset.machineId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast1;
          xfer += iprot->readI32(ecast1);
          this->runningMode = (HostingRunningMode::type)ecast1;
          this->__isset.runningMode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HostingInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("HostingInfo");

  if (this->__isset.status) {
    xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32((int32_t)this->status);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tableVersion) {
    xfer += oprot->writeFieldBegin("tableVersion", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->tableVersion);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.subUserTotalCount) {
    xfer += oprot->writeFieldBegin("subUserTotalCount", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->subUserTotalCount);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.composeTotalCount) {
    xfer += oprot->writeFieldBegin("composeTotalCount", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->composeTotalCount);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.onlineUserTotalCount) {
    xfer += oprot->writeFieldBegin("onlineUserTotalCount", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->onlineUserTotalCount);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.machineId) {
    xfer += oprot->writeFieldBegin("machineId", ::apache::thrift::protocol::T_I64, 6);
    xfer += oprot->writeI64(this->machineId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.runningMode) {
    xfer += oprot->writeFieldBegin("runningMode", ::apache::thrift::protocol::T_I32, 7);
    xfer += oprot->writeI32((int32_t)this->runningMode);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HostingInfo &a, HostingInfo &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.tableVersion, b.tableVersion);
  swap(a.subUserTotalCount, b.subUserTotalCount);
  swap(a.composeTotalCount, b.composeTotalCount);
  swap(a.onlineUserTotalCount, b.onlineUserTotalCount);
  swap(a.machineId, b.machineId);
  swap(a.runningMode, b.runningMode);
  swap(a.__isset, b.__isset);
}

const char* HostingUser::ascii_fingerprint = "3D7C4143D483489E9C09A879EA7BDFA3";
const uint8_t HostingUser::binary_fingerprint[16] = {0x3D,0x7C,0x41,0x43,0xD4,0x83,0x48,0x9E,0x9C,0x09,0xA8,0x79,0xEA,0x7B,0xDF,0xA3};

uint32_t HostingUser::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->subUserId);
          this->__isset.subUserId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->loginName);
          this->__isset.loginName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->loginPasswd);
          this->__isset.loginPasswd = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->phone);
          this->__isset.phone = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->nickName);
          this->__isset.nickName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->userRoleValue);
          this->__isset.userRoleValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->email);
          this->__isset.email = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast2;
          xfer += iprot->readI32(ecast2);
          this->userState = (HostingUserState::type)ecast2;
          this->__isset.userState = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->createTimestamp);
          this->__isset.createTimestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->lastmodifyTimestamp);
          this->__isset.lastmodifyTimestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HostingUser::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("HostingUser");

  if (this->__isset.subUserId) {
    xfer += oprot->writeFieldBegin("subUserId", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->subUserId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.loginName) {
    xfer += oprot->writeFieldBegin("loginName", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->loginName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.loginPasswd) {
    xfer += oprot->writeFieldBegin("loginPasswd", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->loginPasswd);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.phone) {
    xfer += oprot->writeFieldBegin("phone", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->phone);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.nickName) {
    xfer += oprot->writeFieldBegin("nickName", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->nickName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.userRoleValue) {
    xfer += oprot->writeFieldBegin("userRoleValue", ::apache::thrift::protocol::T_I16, 7);
    xfer += oprot->writeI16(this->userRoleValue);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.email) {
    xfer += oprot->writeFieldBegin("email", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->email);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.userState) {
    xfer += oprot->writeFieldBegin("userState", ::apache::thrift::protocol::T_I32, 9);
    xfer += oprot->writeI32((int32_t)this->userState);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.createTimestamp) {
    xfer += oprot->writeFieldBegin("createTimestamp", ::apache::thrift::protocol::T_I32, 15);
    xfer += oprot->writeI32(this->createTimestamp);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.lastmodifyTimestamp) {
    xfer += oprot->writeFieldBegin("lastmodifyTimestamp", ::apache::thrift::protocol::T_I32, 16);
    xfer += oprot->writeI32(this->lastmodifyTimestamp);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HostingUser &a, HostingUser &b) {
  using ::std::swap;
  swap(a.subUserId, b.subUserId);
  swap(a.loginName, b.loginName);
  swap(a.loginPasswd, b.loginPasswd);
  swap(a.phone, b.phone);
  swap(a.nickName, b.nickName);
  swap(a.userRoleValue, b.userRoleValue);
  swap(a.email, b.email);
  swap(a.userState, b.userState);
  swap(a.createTimestamp, b.createTimestamp);
  swap(a.lastmodifyTimestamp, b.lastmodifyTimestamp);
  swap(a.__isset, b.__isset);
}

const char* QueryHostingUserOption::ascii_fingerprint = "4BB210D58D6CCB04EC028DD4B48A7B87";
const uint8_t QueryHostingUserOption::binary_fingerprint[16] = {0x4B,0xB2,0x10,0xD5,0x8D,0x6C,0xCB,0x04,0xEC,0x02,0x8D,0xD4,0xB4,0x8A,0x7B,0x87};

uint32_t QueryHostingUserOption::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->subUserId);
          this->__isset.subUserId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->loginNamePartical);
          this->__isset.loginNamePartical = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->nickNamePartical);
          this->__isset.nickNamePartical = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->loginNameWhole);
          this->__isset.loginNameWhole = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast3;
          xfer += iprot->readI32(ecast3);
          this->orderType = (HostingUserOrderType::type)ecast3;
          this->__isset.orderType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t QueryHostingUserOption::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("QueryHostingUserOption");

  if (this->__isset.subUserId) {
    xfer += oprot->writeFieldBegin("subUserId", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->subUserId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.loginNamePartical) {
    xfer += oprot->writeFieldBegin("loginNamePartical", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->loginNamePartical);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.nickNamePartical) {
    xfer += oprot->writeFieldBegin("nickNamePartical", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->nickNamePartical);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.loginNameWhole) {
    xfer += oprot->writeFieldBegin("loginNameWhole", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->loginNameWhole);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.orderType) {
    xfer += oprot->writeFieldBegin("orderType", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32((int32_t)this->orderType);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(QueryHostingUserOption &a, QueryHostingUserOption &b) {
  using ::std::swap;
  swap(a.subUserId, b.subUserId);
  swap(a.loginNamePartical, b.loginNamePartical);
  swap(a.nickNamePartical, b.nickNamePartical);
  swap(a.loginNameWhole, b.loginNameWhole);
  swap(a.orderType, b.orderType);
  swap(a.__isset, b.__isset);
}

const char* QueryHostingUserPage::ascii_fingerprint = "1CAF60C388192BDA1D2C931AF890318F";
const uint8_t QueryHostingUserPage::binary_fingerprint[16] = {0x1C,0xAF,0x60,0xC3,0x88,0x19,0x2B,0xDA,0x1D,0x2C,0x93,0x1A,0xF8,0x90,0x31,0x8F};

uint32_t QueryHostingUserPage::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->totalCount);
          this->__isset.totalCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->resultList.clear();
            uint32_t _size4;
            ::apache::thrift::protocol::TType _etype7;
            xfer += iprot->readListBegin(_etype7, _size4);
            this->resultList.resize(_size4);
            uint32_t _i8;
            for (_i8 = 0; _i8 < _size4; ++_i8)
            {
              xfer += this->resultList[_i8].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.resultList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t QueryHostingUserPage::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("QueryHostingUserPage");

  if (this->__isset.totalCount) {
    xfer += oprot->writeFieldBegin("totalCount", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32(this->totalCount);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.resultList) {
    xfer += oprot->writeFieldBegin("resultList", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->resultList.size()));
      std::vector<HostingUser> ::const_iterator _iter9;
      for (_iter9 = this->resultList.begin(); _iter9 != this->resultList.end(); ++_iter9)
      {
        xfer += (*_iter9).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(QueryHostingUserPage &a, QueryHostingUserPage &b) {
  using ::std::swap;
  swap(a.totalCount, b.totalCount);
  swap(a.resultList, b.resultList);
  swap(a.__isset, b.__isset);
}

const char* HostingSession::ascii_fingerprint = "121AF9BC294FA0558E93C3C6BE0EAA1F";
const uint8_t HostingSession::binary_fingerprint[16] = {0x12,0x1A,0xF9,0xBC,0x29,0x4F,0xA0,0x55,0x8E,0x93,0xC3,0xC6,0xBE,0x0E,0xAA,0x1F};

uint32_t HostingSession::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->machineId);
          this->__isset.machineId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->subUserId);
          this->__isset.subUserId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->token);
          this->__isset.token = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->loginIP);
          this->__isset.loginIP = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HostingSession::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("HostingSession");

  if (this->__isset.machineId) {
    xfer += oprot->writeFieldBegin("machineId", ::apache::thrift::protocol::T_I64, 1);
    xfer += oprot->writeI64(this->machineId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.subUserId) {
    xfer += oprot->writeFieldBegin("subUserId", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->subUserId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.token) {
    xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->token);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.loginIP) {
    xfer += oprot->writeFieldBegin("loginIP", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->loginIP);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HostingSession &a, HostingSession &b) {
  using ::std::swap;
  swap(a.machineId, b.machineId);
  swap(a.subUserId, b.subUserId);
  swap(a.token, b.token);
  swap(a.loginIP, b.loginIP);
  swap(a.__isset, b.__isset);
}

const char* HostingSubAccount::ascii_fingerprint = "C29DF7CCF0B5C7F94BF19FA6EC5BE502";
const uint8_t HostingSubAccount::binary_fingerprint[16] = {0xC2,0x9D,0xF7,0xCC,0xF0,0xB5,0xC7,0xF9,0x4B,0xF1,0x9F,0xA6,0xEC,0x5B,0xE5,0x02};

uint32_t HostingSubAccount::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->subAccountId);
          this->__isset.subAccountId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->subAccountName);
          this->__isset.subAccountName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->inAmount);
          this->__isset.inAmount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->outAmount);
          this->__isset.outAmount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->createTimestamp);
          this->__isset.createTimestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->lastmodifyTimestamp);
          this->__isset.lastmodifyTimestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HostingSubAccount::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("HostingSubAccount");

  if (this->__isset.subAccountId) {
    xfer += oprot->writeFieldBegin("subAccountId", ::apache::thrift::protocol::T_I64, 1);
    xfer += oprot->writeI64(this->subAccountId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.subAccountName) {
    xfer += oprot->writeFieldBegin("subAccountName", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->subAccountName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.inAmount) {
    xfer += oprot->writeFieldBegin("inAmount", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->inAmount);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.outAmount) {
    xfer += oprot->writeFieldBegin("outAmount", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->outAmount);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.createTimestamp) {
    xfer += oprot->writeFieldBegin("createTimestamp", ::apache::thrift::protocol::T_I32, 8);
    xfer += oprot->writeI32(this->createTimestamp);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.lastmodifyTimestamp) {
    xfer += oprot->writeFieldBegin("lastmodifyTimestamp", ::apache::thrift::protocol::T_I32, 9);
    xfer += oprot->writeI32(this->lastmodifyTimestamp);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HostingSubAccount &a, HostingSubAccount &b) {
  using ::std::swap;
  swap(a.subAccountId, b.subAccountId);
  swap(a.subAccountName, b.subAccountName);
  swap(a.inAmount, b.inAmount);
  swap(a.outAmount, b.outAmount);
  swap(a.createTimestamp, b.createTimestamp);
  swap(a.lastmodifyTimestamp, b.lastmodifyTimestamp);
  swap(a.__isset, b.__isset);
}

const char* HostingSubAccountRelatedItem::ascii_fingerprint = "44AA2FDAAB9D9B57174DBF75FE022858";
const uint8_t HostingSubAccountRelatedItem::binary_fingerprint[16] = {0x44,0xAA,0x2F,0xDA,0xAB,0x9D,0x9B,0x57,0x17,0x4D,0xBF,0x75,0xFE,0x02,0x28,0x58};

uint32_t HostingSubAccountRelatedItem::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->subAccountId);
          this->__isset.subAccountId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->subUserId);
          this->__isset.subUserId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->relatedTimestamp);
          this->__isset.relatedTimestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->subAccountName);
          this->__isset.subAccountName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->subUserLoginName);
          this->__isset.subUserLoginName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->subUserNickName);
          this->__isset.subUserNickName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->lastmodifyTimestamp);
          this->__isset.lastmodifyTimestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HostingSubAccountRelatedItem::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("HostingSubAccountRelatedItem");

  if (this->__isset.subAccountId) {
    xfer += oprot->writeFieldBegin("subAccountId", ::apache::thrift::protocol::T_I64, 1);
    xfer += oprot->writeI64(this->subAccountId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.subUserId) {
    xfer += oprot->writeFieldBegin("subUserId", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->subUserId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.relatedTimestamp) {
    xfer += oprot->writeFieldBegin("relatedTimestamp", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->relatedTimestamp);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.subAccountName) {
    xfer += oprot->writeFieldBegin("subAccountName", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->subAccountName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.subUserLoginName) {
    xfer += oprot->writeFieldBegin("subUserLoginName", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->subUserLoginName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.subUserNickName) {
    xfer += oprot->writeFieldBegin("subUserNickName", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->subUserNickName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.lastmodifyTimestamp) {
    xfer += oprot->writeFieldBegin("lastmodifyTimestamp", ::apache::thrift::protocol::T_I32, 7);
    xfer += oprot->writeI32(this->lastmodifyTimestamp);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HostingSubAccountRelatedItem &a, HostingSubAccountRelatedItem &b) {
  using ::std::swap;
  swap(a.subAccountId, b.subAccountId);
  swap(a.subUserId, b.subUserId);
  swap(a.relatedTimestamp, b.relatedTimestamp);
  swap(a.subAccountName, b.subAccountName);
  swap(a.subUserLoginName, b.subUserLoginName);
  swap(a.subUserNickName, b.subUserNickName);
  swap(a.lastmodifyTimestamp, b.lastmodifyTimestamp);
  swap(a.__isset, b.__isset);
}

const char* HostingComposeLeg::ascii_fingerprint = "F448167111DEAD913234D1B812F7872E";
const uint8_t HostingComposeLeg::binary_fingerprint[16] = {0xF4,0x48,0x16,0x71,0x11,0xDE,0xAD,0x91,0x32,0x34,0xD1,0xB8,0x12,0xF7,0x87,0x2E};

uint32_t HostingComposeLeg::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sledContractId);
          this->__isset.sledContractId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->variableName);
          this->__isset.variableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->quantity);
          this->__isset.quantity = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast10;
          xfer += iprot->readI32(ecast10);
          this->legTradeDirection = (HostingComposeLegTradeDirection::type)ecast10;
          this->__isset.legTradeDirection = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sledContractCode);
          this->__isset.sledContractCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sledCommodityId);
          this->__isset.sledCommodityId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sledCommodityType);
          this->__isset.sledCommodityType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sledCommodityCode);
          this->__isset.sledCommodityCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sledExchangeMic);
          this->__isset.sledExchangeMic = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HostingComposeLeg::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("HostingComposeLeg");

  if (this->__isset.sledContractId) {
    xfer += oprot->writeFieldBegin("sledContractId", ::apache::thrift::protocol::T_I64, 1);
    xfer += oprot->writeI64(this->sledContractId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.variableName) {
    xfer += oprot->writeFieldBegin("variableName", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->variableName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.quantity) {
    xfer += oprot->writeFieldBegin("quantity", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->quantity);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.legTradeDirection) {
    xfer += oprot->writeFieldBegin("legTradeDirection", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32((int32_t)this->legTradeDirection);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.sledContractCode) {
    xfer += oprot->writeFieldBegin("sledContractCode", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->sledContractCode);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.sledCommodityId) {
    xfer += oprot->writeFieldBegin("sledCommodityId", ::apache::thrift::protocol::T_I64, 7);
    xfer += oprot->writeI64(this->sledCommodityId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.sledCommodityType) {
    xfer += oprot->writeFieldBegin("sledCommodityType", ::apache::thrift::protocol::T_I16, 8);
    xfer += oprot->writeI16(this->sledCommodityType);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.sledCommodityCode) {
    xfer += oprot->writeFieldBegin("sledCommodityCode", ::apache::thrift::protocol::T_STRING, 9);
    xfer += oprot->writeString(this->sledCommodityCode);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.sledExchangeMic) {
    xfer += oprot->writeFieldBegin("sledExchangeMic", ::apache::thrift::protocol::T_STRING, 10);
    xfer += oprot->writeString(this->sledExchangeMic);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HostingComposeLeg &a, HostingComposeLeg &b) {
  using ::std::swap;
  swap(a.sledContractId, b.sledContractId);
  swap(a.variableName, b.variableName);
  swap(a.quantity, b.quantity);
  swap(a.legTradeDirection, b.legTradeDirection);
  swap(a.sledContractCode, b.sledContractCode);
  swap(a.sledCommodityId, b.sledCommodityId);
  swap(a.sledCommodityType, b.sledCommodityType);
  swap(a.sledCommodityCode, b.sledCommodityCode);
  swap(a.sledExchangeMic, b.sledExchangeMic);
  swap(a.__isset, b.__isset);
}

const char* HostingComposeGraph::ascii_fingerprint = "7D957169B016414A3909EDD746936283";
const uint8_t HostingComposeGraph::binary_fingerprint[16] = {0x7D,0x95,0x71,0x69,0xB0,0x16,0x41,0x4A,0x39,0x09,0xED,0xD7,0x46,0x93,0x62,0x83};

uint32_t HostingComposeGraph::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->createSubUserId);
          this->__isset.createSubUserId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->composeGraphId);
          this->__isset.composeGraphId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->formular);
          this->__isset.formular = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->legs.clear();
            uint32_t _size11;
            ::apache::thrift::protocol::TType _ktype12;
            ::apache::thrift::protocol::TType _vtype13;
            xfer += iprot->readMapBegin(_ktype12, _vtype13, _size11);
            uint32_t _i15;
            for (_i15 = 0; _i15 < _size11; ++_i15)
            {
              std::string _key16;
              xfer += iprot->readString(_key16);
              HostingComposeLeg& _val17 = this->legs[_key16];
              xfer += _val17.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.legs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->composeGraphKey);
          this->__isset.composeGraphKey = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast18;
          xfer += iprot->readI32(ecast18);
          this->composeGraphEnv = (HostingComposeGraphEnv::type)ecast18;
          this->__isset.composeGraphEnv = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->createTimestamp);
          this->__isset.createTimestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->lastmodifyTimestamp);
          this->__isset.lastmodifyTimestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HostingComposeGraph::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("HostingComposeGraph");

  if (this->__isset.createSubUserId) {
    xfer += oprot->writeFieldBegin("createSubUserId", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32(this->createSubUserId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.composeGraphId) {
    xfer += oprot->writeFieldBegin("composeGraphId", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->composeGraphId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.formular) {
    xfer += oprot->writeFieldBegin("formular", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->formular);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.legs) {
    xfer += oprot->writeFieldBegin("legs", ::apache::thrift::protocol::T_MAP, 4);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->legs.size()));
      std::map<std::string, HostingComposeLeg> ::const_iterator _iter19;
      for (_iter19 = this->legs.begin(); _iter19 != this->legs.end(); ++_iter19)
      {
        xfer += oprot->writeString(_iter19->first);
        xfer += _iter19->second.write(oprot);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.composeGraphKey) {
    xfer += oprot->writeFieldBegin("composeGraphKey", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->composeGraphKey);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.composeGraphEnv) {
    xfer += oprot->writeFieldBegin("composeGraphEnv", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32((int32_t)this->composeGraphEnv);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.createTimestamp) {
    xfer += oprot->writeFieldBegin("createTimestamp", ::apache::thrift::protocol::T_I32, 11);
    xfer += oprot->writeI32(this->createTimestamp);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.lastmodifyTimestamp) {
    xfer += oprot->writeFieldBegin("lastmodifyTimestamp", ::apache::thrift::protocol::T_I32, 12);
    xfer += oprot->writeI32(this->lastmodifyTimestamp);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HostingComposeGraph &a, HostingComposeGraph &b) {
  using ::std::swap;
  swap(a.createSubUserId, b.createSubUserId);
  swap(a.composeGraphId, b.composeGraphId);
  swap(a.formular, b.formular);
  swap(a.legs, b.legs);
  swap(a.composeGraphKey, b.composeGraphKey);
  swap(a.composeGraphEnv, b.composeGraphEnv);
  swap(a.createTimestamp, b.createTimestamp);
  swap(a.lastmodifyTimestamp, b.lastmodifyTimestamp);
  swap(a.__isset, b.__isset);
}

const char* HostingComposeView::ascii_fingerprint = "F396864846F43D08297CE26FA82A8B6A";
const uint8_t HostingComposeView::binary_fingerprint[16] = {0xF3,0x96,0x86,0x48,0x46,0xF4,0x3D,0x08,0x29,0x7C,0xE2,0x6F,0xA8,0x2A,0x8B,0x6A};

uint32_t HostingComposeView::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->subUserId);
          this->__isset.subUserId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->composeGraphId);
          this->__isset.composeGraphId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->aliasName);
          this->__isset.aliasName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast20;
          xfer += iprot->readI32(ecast20);
          this->viewSource = (HostingComposeViewSource::type)ecast20;
          this->__isset.viewSource = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast21;
          xfer += iprot->readI32(ecast21);
          this->subscribeStatus = (HostingComposeViewSubscribeStatus::type)ecast21;
          this->__isset.subscribeStatus = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->createTimestamp);
          this->__isset.createTimestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->lastmodifyTimestamp);
          this->__isset.lastmodifyTimestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HostingComposeView::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("HostingComposeView");

  if (this->__isset.subUserId) {
    xfer += oprot->writeFieldBegin("subUserId", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32(this->subUserId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.composeGraphId) {
    xfer += oprot->writeFieldBegin("composeGraphId", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->composeGraphId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.aliasName) {
    xfer += oprot->writeFieldBegin("aliasName", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->aliasName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.viewSource) {
    xfer += oprot->writeFieldBegin("viewSource", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32((int32_t)this->viewSource);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.subscribeStatus) {
    xfer += oprot->writeFieldBegin("subscribeStatus", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32((int32_t)this->subscribeStatus);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.createTimestamp) {
    xfer += oprot->writeFieldBegin("createTimestamp", ::apache::thrift::protocol::T_I32, 8);
    xfer += oprot->writeI32(this->createTimestamp);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.lastmodifyTimestamp) {
    xfer += oprot->writeFieldBegin("lastmodifyTimestamp", ::apache::thrift::protocol::T_I32, 9);
    xfer += oprot->writeI32(this->lastmodifyTimestamp);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HostingComposeView &a, HostingComposeView &b) {
  using ::std::swap;
  swap(a.subUserId, b.subUserId);
  swap(a.composeGraphId, b.composeGraphId);
  swap(a.aliasName, b.aliasName);
  swap(a.viewSource, b.viewSource);
  swap(a.subscribeStatus, b.subscribeStatus);
  swap(a.createTimestamp, b.createTimestamp);
  swap(a.lastmodifyTimestamp, b.lastmodifyTimestamp);
  swap(a.__isset, b.__isset);
}

const char* HostingTradeAccount::ascii_fingerprint = "63C8645D0BEB0040738BDBD642F5D26A";
const uint8_t HostingTradeAccount::binary_fingerprint[16] = {0x63,0xC8,0x64,0x5D,0x0B,0xEB,0x00,0x40,0x73,0x8B,0xDB,0xD6,0x42,0xF5,0xD2,0x6A};

uint32_t HostingTradeAccount::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->tradeAccountId);
          this->__isset.tradeAccountId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->tradeBrokerAccessId);
          this->__isset.tradeBrokerAccessId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->loginUserName);
          this->__isset.loginUserName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->loginPassword);
          this->__isset.loginPassword = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->accountProperties.clear();
            uint32_t _size22;
            ::apache::thrift::protocol::TType _ktype23;
            ::apache::thrift::protocol::TType _vtype24;
            xfer += iprot->readMapBegin(_ktype23, _vtype24, _size22);
            uint32_t _i26;
            for (_i26 = 0; _i26 < _size22; ++_i26)
            {
              std::string _key27;
              xfer += iprot->readString(_key27);
              std::string& _val28 = this->accountProperties[_key27];
              xfer += iprot->readString(_val28);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.accountProperties = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->tradeBrokerId);
          this->__isset.tradeBrokerId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast29;
          xfer += iprot->readI32(ecast29);
          this->brokerTechPlatform = (BrokerTechPlatform::type)ecast29;
          this->__isset.brokerTechPlatform = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tradeAccountRemark);
          this->__isset.tradeAccountRemark = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast30;
          xfer += iprot->readI32(ecast30);
          this->accountState = (TradeAccountState::type)ecast30;
          this->__isset.accountState = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->invalidReason);
          this->__isset.invalidReason = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->invalidErrorCode);
          this->__isset.invalidErrorCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->apiRetCode);
          this->__isset.apiRetCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast31;
          xfer += iprot->readI32(ecast31);
          this->accountAccessState = (TradeAccountAccessState::type)ecast31;
          this->__isset.accountAccessState = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->hadBeenActived);
          this->__isset.hadBeenActived = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->createTimestamp);
          this->__isset.createTimestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 22:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->lastmodifyTimestamp);
          this->__isset.lastmodifyTimestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HostingTradeAccount::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("HostingTradeAccount");

  if (this->__isset.tradeAccountId) {
    xfer += oprot->writeFieldBegin("tradeAccountId", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->tradeAccountId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tradeBrokerAccessId) {
    xfer += oprot->writeFieldBegin("tradeBrokerAccessId", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->tradeBrokerAccessId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.loginUserName) {
    xfer += oprot->writeFieldBegin("loginUserName", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->loginUserName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.loginPassword) {
    xfer += oprot->writeFieldBegin("loginPassword", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->loginPassword);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.accountProperties) {
    xfer += oprot->writeFieldBegin("accountProperties", ::apache::thrift::protocol::T_MAP, 6);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->accountProperties.size()));
      std::map<std::string, std::string> ::const_iterator _iter32;
      for (_iter32 = this->accountProperties.begin(); _iter32 != this->accountProperties.end(); ++_iter32)
      {
        xfer += oprot->writeString(_iter32->first);
        xfer += oprot->writeString(_iter32->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tradeBrokerId) {
    xfer += oprot->writeFieldBegin("tradeBrokerId", ::apache::thrift::protocol::T_I32, 7);
    xfer += oprot->writeI32(this->tradeBrokerId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.brokerTechPlatform) {
    xfer += oprot->writeFieldBegin("brokerTechPlatform", ::apache::thrift::protocol::T_I32, 8);
    xfer += oprot->writeI32((int32_t)this->brokerTechPlatform);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tradeAccountRemark) {
    xfer += oprot->writeFieldBegin("tradeAccountRemark", ::apache::thrift::protocol::T_STRING, 9);
    xfer += oprot->writeString(this->tradeAccountRemark);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.accountState) {
    xfer += oprot->writeFieldBegin("accountState", ::apache::thrift::protocol::T_I32, 11);
    xfer += oprot->writeI32((int32_t)this->accountState);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.invalidReason) {
    xfer += oprot->writeFieldBegin("invalidReason", ::apache::thrift::protocol::T_STRING, 12);
    xfer += oprot->writeString(this->invalidReason);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.invalidErrorCode) {
    xfer += oprot->writeFieldBegin("invalidErrorCode", ::apache::thrift::protocol::T_I32, 13);
    xfer += oprot->writeI32(this->invalidErrorCode);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.apiRetCode) {
    xfer += oprot->writeFieldBegin("apiRetCode", ::apache::thrift::protocol::T_I32, 14);
    xfer += oprot->writeI32(this->apiRetCode);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.accountAccessState) {
    xfer += oprot->writeFieldBegin("accountAccessState", ::apache::thrift::protocol::T_I32, 15);
    xfer += oprot->writeI32((int32_t)this->accountAccessState);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.hadBeenActived) {
    xfer += oprot->writeFieldBegin("hadBeenActived", ::apache::thrift::protocol::T_BOOL, 16);
    xfer += oprot->writeBool(this->hadBeenActived);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.createTimestamp) {
    xfer += oprot->writeFieldBegin("createTimestamp", ::apache::thrift::protocol::T_I32, 21);
    xfer += oprot->writeI32(this->createTimestamp);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.lastmodifyTimestamp) {
    xfer += oprot->writeFieldBegin("lastmodifyTimestamp", ::apache::thrift::protocol::T_I32, 22);
    xfer += oprot->writeI32(this->lastmodifyTimestamp);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HostingTradeAccount &a, HostingTradeAccount &b) {
  using ::std::swap;
  swap(a.tradeAccountId, b.tradeAccountId);
  swap(a.tradeBrokerAccessId, b.tradeBrokerAccessId);
  swap(a.loginUserName, b.loginUserName);
  swap(a.loginPassword, b.loginPassword);
  swap(a.accountProperties, b.accountProperties);
  swap(a.tradeBrokerId, b.tradeBrokerId);
  swap(a.brokerTechPlatform, b.brokerTechPlatform);
  swap(a.tradeAccountRemark, b.tradeAccountRemark);
  swap(a.accountState, b.accountState);
  swap(a.invalidReason, b.invalidReason);
  swap(a.invalidErrorCode, b.invalidErrorCode);
  swap(a.apiRetCode, b.apiRetCode);
  swap(a.accountAccessState, b.accountAccessState);
  swap(a.hadBeenActived, b.hadBeenActived);
  swap(a.createTimestamp, b.createTimestamp);
  swap(a.lastmodifyTimestamp, b.lastmodifyTimestamp);
  swap(a.__isset, b.__isset);
}

const char* HostingOrderRouteRelatedInfo::ascii_fingerprint = "9C53FFB6CD53A05B88C2CCB56530A5F6";
const uint8_t HostingOrderRouteRelatedInfo::binary_fingerprint[16] = {0x9C,0x53,0xFF,0xB6,0xCD,0x53,0xA0,0x5B,0x88,0xC2,0xCC,0xB5,0x65,0x30,0xA5,0xF6};

uint32_t HostingOrderRouteRelatedInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->forbidden);
          this->__isset.forbidden = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->mainTradeAccountId);
          this->__isset.mainTradeAccountId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HostingOrderRouteRelatedInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("HostingOrderRouteRelatedInfo");

  if (this->__isset.forbidden) {
    xfer += oprot->writeFieldBegin("forbidden", ::apache::thrift::protocol::T_BOOL, 1);
    xfer += oprot->writeBool(this->forbidden);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.mainTradeAccountId) {
    xfer += oprot->writeFieldBegin("mainTradeAccountId", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->mainTradeAccountId);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HostingOrderRouteRelatedInfo &a, HostingOrderRouteRelatedInfo &b) {
  using ::std::swap;
  swap(a.forbidden, b.forbidden);
  swap(a.mainTradeAccountId, b.mainTradeAccountId);
  swap(a.__isset, b.__isset);
}

const char* HostingOrderRouteCommodityCodeNode::ascii_fingerprint = "2215B979326DABA38BB5F462F7F81A01";
const uint8_t HostingOrderRouteCommodityCodeNode::binary_fingerprint[16] = {0x22,0x15,0xB9,0x79,0x32,0x6D,0xAB,0xA3,0x8B,0xB5,0xF4,0x62,0xF7,0xF8,0x1A,0x01};

uint32_t HostingOrderRouteCommodityCodeNode::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sledCommodityCode);
          this->__isset.sledCommodityCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->relatedInfo.read(iprot);
          this->__isset.relatedInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HostingOrderRouteCommodityCodeNode::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("HostingOrderRouteCommodityCodeNode");

  if (this->__isset.sledCommodityCode) {
    xfer += oprot->writeFieldBegin("sledCommodityCode", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->sledCommodityCode);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.relatedInfo) {
    xfer += oprot->writeFieldBegin("relatedInfo", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->relatedInfo.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HostingOrderRouteCommodityCodeNode &a, HostingOrderRouteCommodityCodeNode &b) {
  using ::std::swap;
  swap(a.sledCommodityCode, b.sledCommodityCode);
  swap(a.relatedInfo, b.relatedInfo);
  swap(a.__isset, b.__isset);
}

const char* HostingOrderRouteCommodityTypeNode::ascii_fingerprint = "6A80C3AF379D8E28E8B98BD055A0DB1C";
const uint8_t HostingOrderRouteCommodityTypeNode::binary_fingerprint[16] = {0x6A,0x80,0xC3,0xAF,0x37,0x9D,0x8E,0x28,0xE8,0xB9,0x8B,0xD0,0x55,0xA0,0xDB,0x1C};

uint32_t HostingOrderRouteCommodityTypeNode::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sledCommodityType);
          this->__isset.sledCommodityType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->subCommodityCodeNodes.clear();
            uint32_t _size33;
            ::apache::thrift::protocol::TType _ktype34;
            ::apache::thrift::protocol::TType _vtype35;
            xfer += iprot->readMapBegin(_ktype34, _vtype35, _size33);
            uint32_t _i37;
            for (_i37 = 0; _i37 < _size33; ++_i37)
            {
              std::string _key38;
              xfer += iprot->readString(_key38);
              HostingOrderRouteCommodityCodeNode& _val39 = this->subCommodityCodeNodes[_key38];
              xfer += _val39.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.subCommodityCodeNodes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->relatedInfo.read(iprot);
          this->__isset.relatedInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HostingOrderRouteCommodityTypeNode::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("HostingOrderRouteCommodityTypeNode");

  if (this->__isset.sledCommodityType) {
    xfer += oprot->writeFieldBegin("sledCommodityType", ::apache::thrift::protocol::T_I16, 1);
    xfer += oprot->writeI16(this->sledCommodityType);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.subCommodityCodeNodes) {
    xfer += oprot->writeFieldBegin("subCommodityCodeNodes", ::apache::thrift::protocol::T_MAP, 2);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->subCommodityCodeNodes.size()));
      std::map<std::string, HostingOrderRouteCommodityCodeNode> ::const_iterator _iter40;
      for (_iter40 = this->subCommodityCodeNodes.begin(); _iter40 != this->subCommodityCodeNodes.end(); ++_iter40)
      {
        xfer += oprot->writeString(_iter40->first);
        xfer += _iter40->second.write(oprot);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.relatedInfo) {
    xfer += oprot->writeFieldBegin("relatedInfo", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->relatedInfo.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HostingOrderRouteCommodityTypeNode &a, HostingOrderRouteCommodityTypeNode &b) {
  using ::std::swap;
  swap(a.sledCommodityType, b.sledCommodityType);
  swap(a.subCommodityCodeNodes, b.subCommodityCodeNodes);
  swap(a.relatedInfo, b.relatedInfo);
  swap(a.__isset, b.__isset);
}

const char* HostingOrderRouteExchangeNode::ascii_fingerprint = "52417C722FEA5CB7213E7BA661BCC50C";
const uint8_t HostingOrderRouteExchangeNode::binary_fingerprint[16] = {0x52,0x41,0x7C,0x72,0x2F,0xEA,0x5C,0xB7,0x21,0x3E,0x7B,0xA6,0x61,0xBC,0xC5,0x0C};

uint32_t HostingOrderRouteExchangeNode::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sledExchangeCode);
          this->__isset.sledExchangeCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->subCommodityTypeNodes.clear();
            uint32_t _size41;
            ::apache::thrift::protocol::TType _ktype42;
            ::apache::thrift::protocol::TType _vtype43;
            xfer += iprot->readMapBegin(_ktype42, _vtype43, _size41);
            uint32_t _i45;
            for (_i45 = 0; _i45 < _size41; ++_i45)
            {
              int16_t _key46;
              xfer += iprot->readI16(_key46);
              HostingOrderRouteCommodityTypeNode& _val47 = this->subCommodityTypeNodes[_key46];
              xfer += _val47.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.subCommodityTypeNodes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->relatedInfo.read(iprot);
          this->__isset.relatedInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HostingOrderRouteExchangeNode::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("HostingOrderRouteExchangeNode");

  if (this->__isset.sledExchangeCode) {
    xfer += oprot->writeFieldBegin("sledExchangeCode", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->sledExchangeCode);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.subCommodityTypeNodes) {
    xfer += oprot->writeFieldBegin("subCommodityTypeNodes", ::apache::thrift::protocol::T_MAP, 2);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I16, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->subCommodityTypeNodes.size()));
      std::map<int16_t, HostingOrderRouteCommodityTypeNode> ::const_iterator _iter48;
      for (_iter48 = this->subCommodityTypeNodes.begin(); _iter48 != this->subCommodityTypeNodes.end(); ++_iter48)
      {
        xfer += oprot->writeI16(_iter48->first);
        xfer += _iter48->second.write(oprot);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.relatedInfo) {
    xfer += oprot->writeFieldBegin("relatedInfo", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->relatedInfo.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HostingOrderRouteExchangeNode &a, HostingOrderRouteExchangeNode &b) {
  using ::std::swap;
  swap(a.sledExchangeCode, b.sledExchangeCode);
  swap(a.subCommodityTypeNodes, b.subCommodityTypeNodes);
  swap(a.relatedInfo, b.relatedInfo);
  swap(a.__isset, b.__isset);
}

const char* HostingOrderRouteTree::ascii_fingerprint = "159D9F6514D5C978263AC42DE8C48EA7";
const uint8_t HostingOrderRouteTree::binary_fingerprint[16] = {0x15,0x9D,0x9F,0x65,0x14,0xD5,0xC9,0x78,0x26,0x3A,0xC4,0x2D,0xE8,0xC4,0x8E,0xA7};

uint32_t HostingOrderRouteTree::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->configVersion);
          this->__isset.configVersion = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->subExchangeNodes.clear();
            uint32_t _size49;
            ::apache::thrift::protocol::TType _ktype50;
            ::apache::thrift::protocol::TType _vtype51;
            xfer += iprot->readMapBegin(_ktype50, _vtype51, _size49);
            uint32_t _i53;
            for (_i53 = 0; _i53 < _size49; ++_i53)
            {
              std::string _key54;
              xfer += iprot->readString(_key54);
              HostingOrderRouteExchangeNode& _val55 = this->subExchangeNodes[_key54];
              xfer += _val55.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.subExchangeNodes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HostingOrderRouteTree::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("HostingOrderRouteTree");

  if (this->__isset.configVersion) {
    xfer += oprot->writeFieldBegin("configVersion", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32(this->configVersion);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.subExchangeNodes) {
    xfer += oprot->writeFieldBegin("subExchangeNodes", ::apache::thrift::protocol::T_MAP, 2);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->subExchangeNodes.size()));
      std::map<std::string, HostingOrderRouteExchangeNode> ::const_iterator _iter56;
      for (_iter56 = this->subExchangeNodes.begin(); _iter56 != this->subExchangeNodes.end(); ++_iter56)
      {
        xfer += oprot->writeString(_iter56->first);
        xfer += _iter56->second.write(oprot);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HostingOrderRouteTree &a, HostingOrderRouteTree &b) {
  using ::std::swap;
  swap(a.configVersion, b.configVersion);
  swap(a.subExchangeNodes, b.subExchangeNodes);
  swap(a.__isset, b.__isset);
}

const char* HostingExecOrderDetail::ascii_fingerprint = "DFF43354BBCF85A506D2A2127C644BF7";
const uint8_t HostingExecOrderDetail::binary_fingerprint[16] = {0xDF,0xF4,0x33,0x54,0xBB,0xCF,0x85,0xA5,0x06,0xD2,0xA2,0x12,0x7C,0x64,0x4B,0xF7};

uint32_t HostingExecOrderDetail::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast57;
          xfer += iprot->readI32(ecast57);
          this->orderType = (HostingExecOrderType::type)ecast57;
          this->__isset.orderType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->limitPrice);
          this->__isset.limitPrice = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->quantity);
          this->__isset.quantity = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast58;
          xfer += iprot->readI32(ecast58);
          this->tradeDirection = (HostingExecOrderTradeDirection::type)ecast58;
          this->__isset.tradeDirection = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast59;
          xfer += iprot->readI32(ecast59);
          this->orderCreatorType = (HostingExecOrderCreatorType::type)ecast59;
          this->__isset.orderCreatorType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast60;
          xfer += iprot->readI32(ecast60);
          this->orderMode = (HostingExecOrderMode::type)ecast60;
          this->__isset.orderMode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->effectiveDateTime);
          this->__isset.effectiveDateTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast61;
          xfer += iprot->readI32(ecast61);
          this->condition = (HostingExecOrderCondition::type)ecast61;
          this->__isset.condition = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->conditionPrice);
          this->__isset.conditionPrice = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HostingExecOrderDetail::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("HostingExecOrderDetail");

  if (this->__isset.orderType) {
    xfer += oprot->writeFieldBegin("orderType", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32((int32_t)this->orderType);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.limitPrice) {
    xfer += oprot->writeFieldBegin("limitPrice", ::apache::thrift::protocol::T_DOUBLE, 2);
    xfer += oprot->writeDouble(this->limitPrice);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.quantity) {
    xfer += oprot->writeFieldBegin("quantity", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->quantity);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tradeDirection) {
    xfer += oprot->writeFieldBegin("tradeDirection", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32((int32_t)this->tradeDirection);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.orderCreatorType) {
    xfer += oprot->writeFieldBegin("orderCreatorType", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32((int32_t)this->orderCreatorType);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.orderMode) {
    xfer += oprot->writeFieldBegin("orderMode", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32((int32_t)this->orderMode);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.effectiveDateTime) {
    xfer += oprot->writeFieldBegin("effectiveDateTime", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->effectiveDateTime);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.condition) {
    xfer += oprot->writeFieldBegin("condition", ::apache::thrift::protocol::T_I32, 8);
    xfer += oprot->writeI32((int32_t)this->condition);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.conditionPrice) {
    xfer += oprot->writeFieldBegin("conditionPrice", ::apache::thrift::protocol::T_DOUBLE, 9);
    xfer += oprot->writeDouble(this->conditionPrice);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HostingExecOrderDetail &a, HostingExecOrderDetail &b) {
  using ::std::swap;
  swap(a.orderType, b.orderType);
  swap(a.limitPrice, b.limitPrice);
  swap(a.quantity, b.quantity);
  swap(a.tradeDirection, b.tradeDirection);
  swap(a.orderCreatorType, b.orderCreatorType);
  swap(a.orderMode, b.orderMode);
  swap(a.effectiveDateTime, b.effectiveDateTime);
  swap(a.condition, b.condition);
  swap(a.conditionPrice, b.conditionPrice);
  swap(a.__isset, b.__isset);
}

const char* HostingExecOrderLegContractSummary::ascii_fingerprint = "2DAEAE9042C4FF85356E495DE16B8287";
const uint8_t HostingExecOrderLegContractSummary::binary_fingerprint[16] = {0x2D,0xAE,0xAE,0x90,0x42,0xC4,0xFF,0x85,0x35,0x6E,0x49,0x5D,0xE1,0x6B,0x82,0x87};

uint32_t HostingExecOrderLegContractSummary::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->legSledContractId);
          this->__isset.legSledContractId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->legSledContractCode);
          this->__isset.legSledContractCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->legSledCommodityId);
          this->__isset.legSledCommodityId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->legSledCommodityType);
          this->__isset.legSledCommodityType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->legSledCommodityCode);
          this->__isset.legSledCommodityCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->legSledExchangeMic);
          this->__isset.legSledExchangeMic = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HostingExecOrderLegContractSummary::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("HostingExecOrderLegContractSummary");

  if (this->__isset.legSledContractId) {
    xfer += oprot->writeFieldBegin("legSledContractId", ::apache::thrift::protocol::T_I64, 1);
    xfer += oprot->writeI64(this->legSledContractId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.legSledContractCode) {
    xfer += oprot->writeFieldBegin("legSledContractCode", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->legSledContractCode);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.legSledCommodityId) {
    xfer += oprot->writeFieldBegin("legSledCommodityId", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->legSledCommodityId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.legSledCommodityType) {
    xfer += oprot->writeFieldBegin("legSledCommodityType", ::apache::thrift::protocol::T_I16, 4);
    xfer += oprot->writeI16(this->legSledCommodityType);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.legSledCommodityCode) {
    xfer += oprot->writeFieldBegin("legSledCommodityCode", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->legSledCommodityCode);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.legSledExchangeMic) {
    xfer += oprot->writeFieldBegin("legSledExchangeMic", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->legSledExchangeMic);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HostingExecOrderLegContractSummary &a, HostingExecOrderLegContractSummary &b) {
  using ::std::swap;
  swap(a.legSledContractId, b.legSledContractId);
  swap(a.legSledContractCode, b.legSledContractCode);
  swap(a.legSledCommodityId, b.legSledCommodityId);
  swap(a.legSledCommodityType, b.legSledCommodityType);
  swap(a.legSledCommodityCode, b.legSledCommodityCode);
  swap(a.legSledExchangeMic, b.legSledExchangeMic);
  swap(a.__isset, b.__isset);
}

const char* HostingExecOrderContractSummary::ascii_fingerprint = "9D69E63705AC1B1454063EAFCD752FF3";
const uint8_t HostingExecOrderContractSummary::binary_fingerprint[16] = {0x9D,0x69,0xE6,0x37,0x05,0xAC,0x1B,0x14,0x54,0x06,0x3E,0xAF,0xCD,0x75,0x2F,0xF3};

uint32_t HostingExecOrderContractSummary::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sledContractId);
          this->__isset.sledContractId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sledContractCode);
          this->__isset.sledContractCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sledCommodityId);
          this->__isset.sledCommodityId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sledCommodityType);
          this->__isset.sledCommodityType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sledCommodityCode);
          this->__isset.sledCommodityCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sledExchangeMic);
          this->__isset.sledExchangeMic = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->relatedLegs.clear();
            uint32_t _size62;
            ::apache::thrift::protocol::TType _etype65;
            xfer += iprot->readListBegin(_etype65, _size62);
            this->relatedLegs.resize(_size62);
            uint32_t _i66;
            for (_i66 = 0; _i66 < _size62; ++_i66)
            {
              xfer += this->relatedLegs[_i66].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.relatedLegs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HostingExecOrderContractSummary::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("HostingExecOrderContractSummary");

  if (this->__isset.sledContractId) {
    xfer += oprot->writeFieldBegin("sledContractId", ::apache::thrift::protocol::T_I64, 1);
    xfer += oprot->writeI64(this->sledContractId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.sledContractCode) {
    xfer += oprot->writeFieldBegin("sledContractCode", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->sledContractCode);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.sledCommodityId) {
    xfer += oprot->writeFieldBegin("sledCommodityId", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->sledCommodityId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.sledCommodityType) {
    xfer += oprot->writeFieldBegin("sledCommodityType", ::apache::thrift::protocol::T_I16, 4);
    xfer += oprot->writeI16(this->sledCommodityType);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.sledCommodityCode) {
    xfer += oprot->writeFieldBegin("sledCommodityCode", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->sledCommodityCode);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.sledExchangeMic) {
    xfer += oprot->writeFieldBegin("sledExchangeMic", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->sledExchangeMic);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.relatedLegs) {
    xfer += oprot->writeFieldBegin("relatedLegs", ::apache::thrift::protocol::T_LIST, 7);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->relatedLegs.size()));
      std::vector<HostingExecOrderLegContractSummary> ::const_iterator _iter67;
      for (_iter67 = this->relatedLegs.begin(); _iter67 != this->relatedLegs.end(); ++_iter67)
      {
        xfer += (*_iter67).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HostingExecOrderContractSummary &a, HostingExecOrderContractSummary &b) {
  using ::std::swap;
  swap(a.sledContractId, b.sledContractId);
  swap(a.sledContractCode, b.sledContractCode);
  swap(a.sledCommodityId, b.sledCommodityId);
  swap(a.sledCommodityType, b.sledCommodityType);
  swap(a.sledCommodityCode, b.sledCommodityCode);
  swap(a.sledExchangeMic, b.sledExchangeMic);
  swap(a.relatedLegs, b.relatedLegs);
  swap(a.__isset, b.__isset);
}

const char* HostingExecOrderTradeAccountSummary::ascii_fingerprint = "B5E3CFEC99B5B2149131DC40361D8FE1";
const uint8_t HostingExecOrderTradeAccountSummary::binary_fingerprint[16] = {0xB5,0xE3,0xCF,0xEC,0x99,0xB5,0xB2,0x14,0x91,0x31,0xDC,0x40,0x36,0x1D,0x8F,0xE1};

uint32_t HostingExecOrderTradeAccountSummary::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->tradeAccountId);
          this->__isset.tradeAccountId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->brokerId);
          this->__isset.brokerId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast68;
          xfer += iprot->readI32(ecast68);
          this->techPlatform = (BrokerTechPlatform::type)ecast68;
          this->__isset.techPlatform = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HostingExecOrderTradeAccountSummary::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("HostingExecOrderTradeAccountSummary");

  if (this->__isset.tradeAccountId) {
    xfer += oprot->writeFieldBegin("tradeAccountId", ::apache::thrift::protocol::T_I64, 1);
    xfer += oprot->writeI64(this->tradeAccountId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.brokerId) {
    xfer += oprot->writeFieldBegin("brokerId", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->brokerId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.techPlatform) {
    xfer += oprot->writeFieldBegin("techPlatform", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32((int32_t)this->techPlatform);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HostingExecOrderTradeAccountSummary &a, HostingExecOrderTradeAccountSummary &b) {
  using ::std::swap;
  swap(a.tradeAccountId, b.tradeAccountId);
  swap(a.brokerId, b.brokerId);
  swap(a.techPlatform, b.techPlatform);
  swap(a.__isset, b.__isset);
}

const char* HostingExecOrderState::ascii_fingerprint = "1A99749538798976FB3A4910CD73729D";
const uint8_t HostingExecOrderState::binary_fingerprint[16] = {0x1A,0x99,0x74,0x95,0x38,0x79,0x89,0x76,0xFB,0x3A,0x49,0x10,0xCD,0x73,0x72,0x9D};

uint32_t HostingExecOrderState::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast69;
          xfer += iprot->readI32(ecast69);
          this->value = (HostingExecOrderStateValue::type)ecast69;
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timestampMs);
          this->__isset.timestampMs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HostingExecOrderState::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("HostingExecOrderState");

  if (this->__isset.value) {
    xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32((int32_t)this->value);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.timestampMs) {
    xfer += oprot->writeFieldBegin("timestampMs", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->timestampMs);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HostingExecOrderState &a, HostingExecOrderState &b) {
  using ::std::swap;
  swap(a.value, b.value);
  swap(a.timestampMs, b.timestampMs);
  swap(a.__isset, b.__isset);
}

const char* HostingExecOrderStateInfo::ascii_fingerprint = "3F983584A1A1F3CCD9DABD3633D47562";
const uint8_t HostingExecOrderStateInfo::binary_fingerprint[16] = {0x3F,0x98,0x35,0x84,0xA1,0xA1,0xF3,0xCC,0xD9,0xDA,0xBD,0x36,0x33,0xD4,0x75,0x62};

uint32_t HostingExecOrderStateInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->currentState.read(iprot);
          this->__isset.currentState = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->historyStates.clear();
            uint32_t _size70;
            ::apache::thrift::protocol::TType _etype73;
            xfer += iprot->readListBegin(_etype73, _size70);
            this->historyStates.resize(_size70);
            uint32_t _i74;
            for (_i74 = 0; _i74 < _size70; ++_i74)
            {
              xfer += this->historyStates[_i74].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.historyStates = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->statusMsg);
          this->__isset.statusMsg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->failedErrorCode);
          this->__isset.failedErrorCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->upsideErrorCode);
          this->__isset.upsideErrorCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->upsideUsefulMsg);
          this->__isset.upsideUsefulMsg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HostingExecOrderStateInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("HostingExecOrderStateInfo");

  if (this->__isset.currentState) {
    xfer += oprot->writeFieldBegin("currentState", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->currentState.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.historyStates) {
    xfer += oprot->writeFieldBegin("historyStates", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->historyStates.size()));
      std::vector<HostingExecOrderState> ::const_iterator _iter75;
      for (_iter75 = this->historyStates.begin(); _iter75 != this->historyStates.end(); ++_iter75)
      {
        xfer += (*_iter75).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.statusMsg) {
    xfer += oprot->writeFieldBegin("statusMsg", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->statusMsg);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.failedErrorCode) {
    xfer += oprot->writeFieldBegin("failedErrorCode", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->failedErrorCode);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.upsideErrorCode) {
    xfer += oprot->writeFieldBegin("upsideErrorCode", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->upsideErrorCode);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.upsideUsefulMsg) {
    xfer += oprot->writeFieldBegin("upsideUsefulMsg", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->upsideUsefulMsg);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HostingExecOrderStateInfo &a, HostingExecOrderStateInfo &b) {
  using ::std::swap;
  swap(a.currentState, b.currentState);
  swap(a.historyStates, b.historyStates);
  swap(a.statusMsg, b.statusMsg);
  swap(a.failedErrorCode, b.failedErrorCode);
  swap(a.upsideErrorCode, b.upsideErrorCode);
  swap(a.upsideUsefulMsg, b.upsideUsefulMsg);
  swap(a.__isset, b.__isset);
}

const char* HostingExecOrderRevokeInfo::ascii_fingerprint = "A403959AB21B2E33847512A23F40CCE6";
const uint8_t HostingExecOrderRevokeInfo::binary_fingerprint[16] = {0xA4,0x03,0x95,0x9A,0xB2,0x1B,0x2E,0x33,0x84,0x75,0x12,0xA2,0x3F,0x40,0xCC,0xE6};

uint32_t HostingExecOrderRevokeInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lastRevokeTimestampMs);
          this->__isset.lastRevokeTimestampMs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->lastRevokeFailedErrorCode);
          this->__isset.lastRevokeFailedErrorCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->lastRevokeUpsideErrorCode);
          this->__isset.lastRevokeUpsideErrorCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->lastRevokeUpsideRejectReason);
          this->__isset.lastRevokeUpsideRejectReason = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HostingExecOrderRevokeInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("HostingExecOrderRevokeInfo");

  if (this->__isset.lastRevokeTimestampMs) {
    xfer += oprot->writeFieldBegin("lastRevokeTimestampMs", ::apache::thrift::protocol::T_I64, 1);
    xfer += oprot->writeI64(this->lastRevokeTimestampMs);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.lastRevokeFailedErrorCode) {
    xfer += oprot->writeFieldBegin("lastRevokeFailedErrorCode", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->lastRevokeFailedErrorCode);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.lastRevokeUpsideErrorCode) {
    xfer += oprot->writeFieldBegin("lastRevokeUpsideErrorCode", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->lastRevokeUpsideErrorCode);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.lastRevokeUpsideRejectReason) {
    xfer += oprot->writeFieldBegin("lastRevokeUpsideRejectReason", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->lastRevokeUpsideRejectReason);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HostingExecOrderRevokeInfo &a, HostingExecOrderRevokeInfo &b) {
  using ::std::swap;
  swap(a.lastRevokeTimestampMs, b.lastRevokeTimestampMs);
  swap(a.lastRevokeFailedErrorCode, b.lastRevokeFailedErrorCode);
  swap(a.lastRevokeUpsideErrorCode, b.lastRevokeUpsideErrorCode);
  swap(a.lastRevokeUpsideRejectReason, b.lastRevokeUpsideRejectReason);
  swap(a.__isset, b.__isset);
}

const char* CTPOrderRef::ascii_fingerprint = "F274D66FD49A613E4D8C874F5A58A038";
const uint8_t CTPOrderRef::binary_fingerprint[16] = {0xF2,0x74,0xD6,0x6F,0xD4,0x9A,0x61,0x3E,0x4D,0x8C,0x87,0x4F,0x5A,0x58,0xA0,0x38};

uint32_t CTPOrderRef::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->frontID);
          this->__isset.frontID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->sessionID);
          this->__isset.sessionID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->orderRef);
          this->__isset.orderRef = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTPOrderRef::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CTPOrderRef");

  if (this->__isset.frontID) {
    xfer += oprot->writeFieldBegin("frontID", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32(this->frontID);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.sessionID) {
    xfer += oprot->writeFieldBegin("sessionID", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->sessionID);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.orderRef) {
    xfer += oprot->writeFieldBegin("orderRef", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->orderRef);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CTPOrderRef &a, CTPOrderRef &b) {
  using ::std::swap;
  swap(a.frontID, b.frontID);
  swap(a.sessionID, b.sessionID);
  swap(a.orderRef, b.orderRef);
  swap(a.__isset, b.__isset);
}

const char* ESunny3OrderRef::ascii_fingerprint = "66E694018C17E5B65A59AE8F55CCA3CD";
const uint8_t ESunny3OrderRef::binary_fingerprint[16] = {0x66,0xE6,0x94,0x01,0x8C,0x17,0xE5,0xB6,0x5A,0x59,0xAE,0x8F,0x55,0xCC,0xA3,0xCD};

uint32_t ESunny3OrderRef::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->saveString);
          this->__isset.saveString = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ESunny3OrderRef::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ESunny3OrderRef");

  if (this->__isset.saveString) {
    xfer += oprot->writeFieldBegin("saveString", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->saveString);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ESunny3OrderRef &a, ESunny3OrderRef &b) {
  using ::std::swap;
  swap(a.saveString, b.saveString);
  swap(a.__isset, b.__isset);
}

const char* ESunny9OrderRef::ascii_fingerprint = "66E694018C17E5B65A59AE8F55CCA3CD";
const uint8_t ESunny9OrderRef::binary_fingerprint[16] = {0x66,0xE6,0x94,0x01,0x8C,0x17,0xE5,0xB6,0x5A,0x59,0xAE,0x8F,0x55,0xCC,0xA3,0xCD};

uint32_t ESunny9OrderRef::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->refString);
          this->__isset.refString = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ESunny9OrderRef::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ESunny9OrderRef");

  if (this->__isset.refString) {
    xfer += oprot->writeFieldBegin("refString", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->refString);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ESunny9OrderRef &a, ESunny9OrderRef &b) {
  using ::std::swap;
  swap(a.refString, b.refString);
  swap(a.__isset, b.__isset);
}

const char* HostingExecOrderRef::ascii_fingerprint = "C2A739E5F794ACF8EB1A8E0B27D8A321";
const uint8_t HostingExecOrderRef::binary_fingerprint[16] = {0xC2,0xA7,0x39,0xE5,0xF7,0x94,0xAC,0xF8,0xEB,0x1A,0x8E,0x0B,0x27,0xD8,0xA3,0x21};

uint32_t HostingExecOrderRef::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ctpRef.read(iprot);
          this->__isset.ctpRef = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->esunny3Ref.read(iprot);
          this->__isset.esunny3Ref = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->esunny9Ref.read(iprot);
          this->__isset.esunny9Ref = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HostingExecOrderRef::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("HostingExecOrderRef");

  if (this->__isset.ctpRef) {
    xfer += oprot->writeFieldBegin("ctpRef", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ctpRef.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.esunny3Ref) {
    xfer += oprot->writeFieldBegin("esunny3Ref", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->esunny3Ref.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.esunny9Ref) {
    xfer += oprot->writeFieldBegin("esunny9Ref", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->esunny9Ref.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HostingExecOrderRef &a, HostingExecOrderRef &b) {
  using ::std::swap;
  swap(a.ctpRef, b.ctpRef);
  swap(a.esunny3Ref, b.esunny3Ref);
  swap(a.esunny9Ref, b.esunny9Ref);
  swap(a.__isset, b.__isset);
}

const char* CTPContractSummary::ascii_fingerprint = "416195F4560887440B74077B51AEDE0D";
const uint8_t CTPContractSummary::binary_fingerprint[16] = {0x41,0x61,0x95,0xF4,0x56,0x08,0x87,0x44,0x0B,0x74,0x07,0x7B,0x51,0xAE,0xDE,0x0D};

uint32_t CTPContractSummary::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ctpExchangeCode);
          this->__isset.ctpExchangeCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ctpCommodityCode);
          this->__isset.ctpCommodityCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->ctpCommodityType);
          this->__isset.ctpCommodityType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ctpContractCode);
          this->__isset.ctpContractCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTPContractSummary::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CTPContractSummary");

  if (this->__isset.ctpExchangeCode) {
    xfer += oprot->writeFieldBegin("ctpExchangeCode", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->ctpExchangeCode);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ctpCommodityCode) {
    xfer += oprot->writeFieldBegin("ctpCommodityCode", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->ctpCommodityCode);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ctpCommodityType) {
    xfer += oprot->writeFieldBegin("ctpCommodityType", ::apache::thrift::protocol::T_I16, 3);
    xfer += oprot->writeI16(this->ctpCommodityType);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ctpContractCode) {
    xfer += oprot->writeFieldBegin("ctpContractCode", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->ctpContractCode);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CTPContractSummary &a, CTPContractSummary &b) {
  using ::std::swap;
  swap(a.ctpExchangeCode, b.ctpExchangeCode);
  swap(a.ctpCommodityCode, b.ctpCommodityCode);
  swap(a.ctpCommodityType, b.ctpCommodityType);
  swap(a.ctpContractCode, b.ctpContractCode);
  swap(a.__isset, b.__isset);
}

const char* CTPOrderInputExt::ascii_fingerprint = "E453F04FB868B3AD5691DCCAEB50C8E1";
const uint8_t CTPOrderInputExt::binary_fingerprint[16] = {0xE4,0x53,0xF0,0x4F,0xB8,0x68,0xB3,0xAD,0x56,0x91,0xDC,0xCA,0xEB,0x50,0xC8,0xE1};

uint32_t CTPOrderInputExt::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->contractSummary.read(iprot);
          this->__isset.contractSummary = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast76;
          xfer += iprot->readI32(ecast76);
          this->combOffsetFlag = (CTPCombOffsetFlagType::type)ecast76;
          this->__isset.combOffsetFlag = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->minVolume);
          this->__isset.minVolume = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast77;
          xfer += iprot->readI32(ecast77);
          this->combHedgeFlag = (CTPCombHedgeFlagType::type)ecast77;
          this->__isset.combHedgeFlag = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast78;
          xfer += iprot->readI32(ecast78);
          this->tradeDirection = (CTPTradeDirection::type)ecast78;
          this->__isset.tradeDirection = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTPOrderInputExt::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CTPOrderInputExt");

  if (this->__isset.contractSummary) {
    xfer += oprot->writeFieldBegin("contractSummary", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->contractSummary.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.combOffsetFlag) {
    xfer += oprot->writeFieldBegin("combOffsetFlag", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32((int32_t)this->combOffsetFlag);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.minVolume) {
    xfer += oprot->writeFieldBegin("minVolume", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->minVolume);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.combHedgeFlag) {
    xfer += oprot->writeFieldBegin("combHedgeFlag", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32((int32_t)this->combHedgeFlag);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tradeDirection) {
    xfer += oprot->writeFieldBegin("tradeDirection", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32((int32_t)this->tradeDirection);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CTPOrderInputExt &a, CTPOrderInputExt &b) {
  using ::std::swap;
  swap(a.contractSummary, b.contractSummary);
  swap(a.combOffsetFlag, b.combOffsetFlag);
  swap(a.minVolume, b.minVolume);
  swap(a.combHedgeFlag, b.combHedgeFlag);
  swap(a.tradeDirection, b.tradeDirection);
  swap(a.__isset, b.__isset);
}

const char* ESunny3ContractSummary::ascii_fingerprint = "A20F62CD65726B66757DDB38ECFADDF5";
const uint8_t ESunny3ContractSummary::binary_fingerprint[16] = {0xA2,0x0F,0x62,0xCD,0x65,0x72,0x6B,0x66,0x75,0x7D,0xDB,0x38,0xEC,0xFA,0xDD,0xF5};

uint32_t ESunny3ContractSummary::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->esunny3ExchangeCode);
          this->__isset.esunny3ExchangeCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->esunny3CommodityType);
          this->__isset.esunny3CommodityType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->esunny3CommodityCode);
          this->__isset.esunny3CommodityCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->esunny3ContractCode);
          this->__isset.esunny3ContractCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ESunny3ContractSummary::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ESunny3ContractSummary");

  if (this->__isset.esunny3ExchangeCode) {
    xfer += oprot->writeFieldBegin("esunny3ExchangeCode", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->esunny3ExchangeCode);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.esunny3CommodityType) {
    xfer += oprot->writeFieldBegin("esunny3CommodityType", ::apache::thrift::protocol::T_I16, 2);
    xfer += oprot->writeI16(this->esunny3CommodityType);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.esunny3CommodityCode) {
    xfer += oprot->writeFieldBegin("esunny3CommodityCode", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->esunny3CommodityCode);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.esunny3ContractCode) {
    xfer += oprot->writeFieldBegin("esunny3ContractCode", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->esunny3ContractCode);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ESunny3ContractSummary &a, ESunny3ContractSummary &b) {
  using ::std::swap;
  swap(a.esunny3ExchangeCode, b.esunny3ExchangeCode);
  swap(a.esunny3CommodityType, b.esunny3CommodityType);
  swap(a.esunny3CommodityCode, b.esunny3CommodityCode);
  swap(a.esunny3ContractCode, b.esunny3ContractCode);
  swap(a.__isset, b.__isset);
}

const char* ESunny3OrderInputExt::ascii_fingerprint = "50694A75315A56AE424E5602AD0563CF";
const uint8_t ESunny3OrderInputExt::binary_fingerprint[16] = {0x50,0x69,0x4A,0x75,0x31,0x5A,0x56,0xAE,0x42,0x4E,0x56,0x02,0xAD,0x05,0x63,0xCF};

uint32_t ESunny3OrderInputExt::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->contractSummary.read(iprot);
          this->__isset.contractSummary = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ESunny3OrderInputExt::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ESunny3OrderInputExt");

  if (this->__isset.contractSummary) {
    xfer += oprot->writeFieldBegin("contractSummary", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->contractSummary.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ESunny3OrderInputExt &a, ESunny3OrderInputExt &b) {
  using ::std::swap;
  swap(a.contractSummary, b.contractSummary);
  swap(a.__isset, b.__isset);
}

const char* ESunny9ContractSummary::ascii_fingerprint = "31C01B41E14D852FEED48A0B8C26C3A9";
const uint8_t ESunny9ContractSummary::binary_fingerprint[16] = {0x31,0xC0,0x1B,0x41,0xE1,0x4D,0x85,0x2F,0xEE,0xD4,0x8A,0x0B,0x8C,0x26,0xC3,0xA9};

uint32_t ESunny9ContractSummary::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->esunny9ExchangeNo);
          this->__isset.esunny9ExchangeNo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->esunny9CommodityType);
          this->__isset.esunny9CommodityType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->esunny9CommodityNo);
          this->__isset.esunny9CommodityNo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->esunny9ContractNo);
          this->__isset.esunny9ContractNo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->esunny9ContractNo2);
          this->__isset.esunny9ContractNo2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ESunny9ContractSummary::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ESunny9ContractSummary");

  if (this->__isset.esunny9ExchangeNo) {
    xfer += oprot->writeFieldBegin("esunny9ExchangeNo", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->esunny9ExchangeNo);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.esunny9CommodityType) {
    xfer += oprot->writeFieldBegin("esunny9CommodityType", ::apache::thrift::protocol::T_I16, 2);
    xfer += oprot->writeI16(this->esunny9CommodityType);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.esunny9CommodityNo) {
    xfer += oprot->writeFieldBegin("esunny9CommodityNo", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->esunny9CommodityNo);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.esunny9ContractNo) {
    xfer += oprot->writeFieldBegin("esunny9ContractNo", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->esunny9ContractNo);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.esunny9ContractNo2) {
    xfer += oprot->writeFieldBegin("esunny9ContractNo2", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->esunny9ContractNo2);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ESunny9ContractSummary &a, ESunny9ContractSummary &b) {
  using ::std::swap;
  swap(a.esunny9ExchangeNo, b.esunny9ExchangeNo);
  swap(a.esunny9CommodityType, b.esunny9CommodityType);
  swap(a.esunny9CommodityNo, b.esunny9CommodityNo);
  swap(a.esunny9ContractNo, b.esunny9ContractNo);
  swap(a.esunny9ContractNo2, b.esunny9ContractNo2);
  swap(a.__isset, b.__isset);
}

const char* ESunny9OrderInputExt::ascii_fingerprint = "DE57D13395BE71C0CB7EDC59D8E7018F";
const uint8_t ESunny9OrderInputExt::binary_fingerprint[16] = {0xDE,0x57,0xD1,0x33,0x95,0xBE,0x71,0xC0,0xCB,0x7E,0xDC,0x59,0xD8,0xE7,0x01,0x8F};

uint32_t ESunny9OrderInputExt::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->contractSummary.read(iprot);
          this->__isset.contractSummary = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ESunny9OrderInputExt::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ESunny9OrderInputExt");

  if (this->__isset.contractSummary) {
    xfer += oprot->writeFieldBegin("contractSummary", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->contractSummary.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ESunny9OrderInputExt &a, ESunny9OrderInputExt &b) {
  using ::std::swap;
  swap(a.contractSummary, b.contractSummary);
  swap(a.__isset, b.__isset);
}

const char* HostingExecOrderInputExt::ascii_fingerprint = "56F88AFEF5C370339ACCC06307345745";
const uint8_t HostingExecOrderInputExt::binary_fingerprint[16] = {0x56,0xF8,0x8A,0xFE,0xF5,0xC3,0x70,0x33,0x9A,0xCC,0xC0,0x63,0x07,0x34,0x57,0x45};

uint32_t HostingExecOrderInputExt::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ctpInputExt.read(iprot);
          this->__isset.ctpInputExt = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->esunny3InputExt.read(iprot);
          this->__isset.esunny3InputExt = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->esunny9InputExt.read(iprot);
          this->__isset.esunny9InputExt = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HostingExecOrderInputExt::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("HostingExecOrderInputExt");

  if (this->__isset.ctpInputExt) {
    xfer += oprot->writeFieldBegin("ctpInputExt", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ctpInputExt.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.esunny3InputExt) {
    xfer += oprot->writeFieldBegin("esunny3InputExt", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->esunny3InputExt.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.esunny9InputExt) {
    xfer += oprot->writeFieldBegin("esunny9InputExt", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->esunny9InputExt.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HostingExecOrderInputExt &a, HostingExecOrderInputExt &b) {
  using ::std::swap;
  swap(a.ctpInputExt, b.ctpInputExt);
  swap(a.esunny3InputExt, b.esunny3InputExt);
  swap(a.esunny9InputExt, b.esunny9InputExt);
  swap(a.__isset, b.__isset);
}

const char* CTPDealID::ascii_fingerprint = "D0297FC5011701BD87898CC36146A565";
const uint8_t CTPDealID::binary_fingerprint[16] = {0xD0,0x29,0x7F,0xC5,0x01,0x17,0x01,0xBD,0x87,0x89,0x8C,0xC3,0x61,0x46,0xA5,0x65};

uint32_t CTPDealID::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->orderSysId);
          this->__isset.orderSysId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->exchangeId);
          this->__isset.exchangeId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTPDealID::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CTPDealID");

  if (this->__isset.orderSysId) {
    xfer += oprot->writeFieldBegin("orderSysId", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->orderSysId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.exchangeId) {
    xfer += oprot->writeFieldBegin("exchangeId", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->exchangeId);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CTPDealID &a, CTPDealID &b) {
  using ::std::swap;
  swap(a.orderSysId, b.orderSysId);
  swap(a.exchangeId, b.exchangeId);
  swap(a.__isset, b.__isset);
}

const char* ESunny3DealID::ascii_fingerprint = "E7A96B151330359E84C0A3AC91BCBACD";
const uint8_t ESunny3DealID::binary_fingerprint[16] = {0xE7,0xA9,0x6B,0x15,0x13,0x30,0x35,0x9E,0x84,0xC0,0xA3,0xAC,0x91,0xBC,0xBA,0xCD};

uint32_t ESunny3DealID::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->orderId);
          this->__isset.orderId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ESunny3DealID::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ESunny3DealID");

  if (this->__isset.orderId) {
    xfer += oprot->writeFieldBegin("orderId", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32(this->orderId);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ESunny3DealID &a, ESunny3DealID &b) {
  using ::std::swap;
  swap(a.orderId, b.orderId);
  swap(a.__isset, b.__isset);
}

const char* ESunny9DealID::ascii_fingerprint = "66E694018C17E5B65A59AE8F55CCA3CD";
const uint8_t ESunny9DealID::binary_fingerprint[16] = {0x66,0xE6,0x94,0x01,0x8C,0x17,0xE5,0xB6,0x5A,0x59,0xAE,0x8F,0x55,0xCC,0xA3,0xCD};

uint32_t ESunny9DealID::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->orderNo);
          this->__isset.orderNo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ESunny9DealID::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ESunny9DealID");

  if (this->__isset.orderNo) {
    xfer += oprot->writeFieldBegin("orderNo", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->orderNo);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ESunny9DealID &a, ESunny9DealID &b) {
  using ::std::swap;
  swap(a.orderNo, b.orderNo);
  swap(a.__isset, b.__isset);
}

const char* HostingExecOrderDealID::ascii_fingerprint = "BB835BBE1089C214DBFDED42BE6F3D93";
const uint8_t HostingExecOrderDealID::binary_fingerprint[16] = {0xBB,0x83,0x5B,0xBE,0x10,0x89,0xC2,0x14,0xDB,0xFD,0xED,0x42,0xBE,0x6F,0x3D,0x93};

uint32_t HostingExecOrderDealID::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ctpDealId.read(iprot);
          this->__isset.ctpDealId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->esunny3DealId.read(iprot);
          this->__isset.esunny3DealId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->esunny9DealId.read(iprot);
          this->__isset.esunny9DealId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HostingExecOrderDealID::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("HostingExecOrderDealID");

  if (this->__isset.ctpDealId) {
    xfer += oprot->writeFieldBegin("ctpDealId", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ctpDealId.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.esunny3DealId) {
    xfer += oprot->writeFieldBegin("esunny3DealId", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->esunny3DealId.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.esunny9DealId) {
    xfer += oprot->writeFieldBegin("esunny9DealId", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->esunny9DealId.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HostingExecOrderDealID &a, HostingExecOrderDealID &b) {
  using ::std::swap;
  swap(a.ctpDealId, b.ctpDealId);
  swap(a.esunny3DealId, b.esunny3DealId);
  swap(a.esunny9DealId, b.esunny9DealId);
  swap(a.__isset, b.__isset);
}

const char* HostingExecOrderDealCTPInfo::ascii_fingerprint = "5AD377B1094BE50585009735A35AB7BD";
const uint8_t HostingExecOrderDealCTPInfo::binary_fingerprint[16] = {0x5A,0xD3,0x77,0xB1,0x09,0x4B,0xE5,0x05,0x85,0x00,0x97,0x35,0xA3,0x5A,0xB7,0xBD};

uint32_t HostingExecOrderDealCTPInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast79;
          xfer += iprot->readI32(ecast79);
          this->offsetFlag = (CTPCombOffsetFlagType::type)ecast79;
          this->__isset.offsetFlag = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast80;
          xfer += iprot->readI32(ecast80);
          this->tradeDirection = (CTPTradeDirection::type)ecast80;
          this->__isset.tradeDirection = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HostingExecOrderDealCTPInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("HostingExecOrderDealCTPInfo");

  if (this->__isset.offsetFlag) {
    xfer += oprot->writeFieldBegin("offsetFlag", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32((int32_t)this->offsetFlag);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tradeDirection) {
    xfer += oprot->writeFieldBegin("tradeDirection", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32((int32_t)this->tradeDirection);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HostingExecOrderDealCTPInfo &a, HostingExecOrderDealCTPInfo &b) {
  using ::std::swap;
  swap(a.offsetFlag, b.offsetFlag);
  swap(a.tradeDirection, b.tradeDirection);
  swap(a.__isset, b.__isset);
}

const char* HostingExecOrderDealESunny9Info::ascii_fingerprint = "E487362AE8D03F4BFCF95C46679FAF19";
const uint8_t HostingExecOrderDealESunny9Info::binary_fingerprint[16] = {0xE4,0x87,0x36,0x2A,0xE8,0xD0,0x3F,0x4B,0xFC,0xF9,0x5C,0x46,0x67,0x9F,0xAF,0x19};

uint32_t HostingExecOrderDealESunny9Info::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->serverFlag);
          this->__isset.serverFlag = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->isAddOne);
          this->__isset.isAddOne = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HostingExecOrderDealESunny9Info::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("HostingExecOrderDealESunny9Info");

  if (this->__isset.serverFlag) {
    xfer += oprot->writeFieldBegin("serverFlag", ::apache::thrift::protocol::T_BYTE, 1);
    xfer += oprot->writeByte(this->serverFlag);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.isAddOne) {
    xfer += oprot->writeFieldBegin("isAddOne", ::apache::thrift::protocol::T_BYTE, 2);
    xfer += oprot->writeByte(this->isAddOne);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HostingExecOrderDealESunny9Info &a, HostingExecOrderDealESunny9Info &b) {
  using ::std::swap;
  swap(a.serverFlag, b.serverFlag);
  swap(a.isAddOne, b.isAddOne);
  swap(a.__isset, b.__isset);
}

const char* HostingExecOrderDealInfo::ascii_fingerprint = "E8FB4EE29075BE8D10D89152B1713EFD";
const uint8_t HostingExecOrderDealInfo::binary_fingerprint[16] = {0xE8,0xFB,0x4E,0xE2,0x90,0x75,0xBE,0x8D,0x10,0xD8,0x91,0x52,0xB1,0x71,0x3E,0xFD};

uint32_t HostingExecOrderDealInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->dealId.read(iprot);
          this->__isset.dealId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->orderInsertDateTime);
          this->__isset.orderInsertDateTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ctpDealInfo.read(iprot);
          this->__isset.ctpDealInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->esunny9DealInfo.read(iprot);
          this->__isset.esunny9DealInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HostingExecOrderDealInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("HostingExecOrderDealInfo");

  if (this->__isset.dealId) {
    xfer += oprot->writeFieldBegin("dealId", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->dealId.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.orderInsertDateTime) {
    xfer += oprot->writeFieldBegin("orderInsertDateTime", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->orderInsertDateTime);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ctpDealInfo) {
    xfer += oprot->writeFieldBegin("ctpDealInfo", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->ctpDealInfo.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.esunny9DealInfo) {
    xfer += oprot->writeFieldBegin("esunny9DealInfo", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->esunny9DealInfo.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HostingExecOrderDealInfo &a, HostingExecOrderDealInfo &b) {
  using ::std::swap;
  swap(a.dealId, b.dealId);
  swap(a.orderInsertDateTime, b.orderInsertDateTime);
  swap(a.ctpDealInfo, b.ctpDealInfo);
  swap(a.esunny9DealInfo, b.esunny9DealInfo);
  swap(a.__isset, b.__isset);
}

const char* HostingUpsideNotifyStateInfo::ascii_fingerprint = "D94763F9C5CFAFD64476D0A26B1D73B0";
const uint8_t HostingUpsideNotifyStateInfo::binary_fingerprint[16] = {0xD9,0x47,0x63,0xF9,0xC5,0xCF,0xAF,0xD6,0x44,0x76,0xD0,0xA2,0x6B,0x1D,0x73,0xB0};

uint32_t HostingUpsideNotifyStateInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast81;
          xfer += iprot->readI32(ecast81);
          this->state = (HostingUpsideNotifyStateType::type)ecast81;
          this->__isset.state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->dealInfo.read(iprot);
          this->__isset.dealInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->volumeTraded);
          this->__isset.volumeTraded = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->volumeResting);
          this->__isset.volumeResting = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->tradeAveragePrice);
          this->__isset.tradeAveragePrice = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->statusUsefulMsg);
          this->__isset.statusUsefulMsg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HostingUpsideNotifyStateInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("HostingUpsideNotifyStateInfo");

  if (this->__isset.state) {
    xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32((int32_t)this->state);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.dealInfo) {
    xfer += oprot->writeFieldBegin("dealInfo", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->dealInfo.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.volumeTraded) {
    xfer += oprot->writeFieldBegin("volumeTraded", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32(this->volumeTraded);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.volumeResting) {
    xfer += oprot->writeFieldBegin("volumeResting", ::apache::thrift::protocol::T_I32, 7);
    xfer += oprot->writeI32(this->volumeResting);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tradeAveragePrice) {
    xfer += oprot->writeFieldBegin("tradeAveragePrice", ::apache::thrift::protocol::T_DOUBLE, 8);
    xfer += oprot->writeDouble(this->tradeAveragePrice);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.statusUsefulMsg) {
    xfer += oprot->writeFieldBegin("statusUsefulMsg", ::apache::thrift::protocol::T_STRING, 9);
    xfer += oprot->writeString(this->statusUsefulMsg);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HostingUpsideNotifyStateInfo &a, HostingUpsideNotifyStateInfo &b) {
  using ::std::swap;
  swap(a.state, b.state);
  swap(a.dealInfo, b.dealInfo);
  swap(a.volumeTraded, b.volumeTraded);
  swap(a.volumeResting, b.volumeResting);
  swap(a.tradeAveragePrice, b.tradeAveragePrice);
  swap(a.statusUsefulMsg, b.statusUsefulMsg);
  swap(a.__isset, b.__isset);
}

const char* HostingUpsideNotifyStateHandleInfo::ascii_fingerprint = "B4D844F022E04A47222F1BD131745BE7";
const uint8_t HostingUpsideNotifyStateHandleInfo::binary_fingerprint[16] = {0xB4,0xD8,0x44,0xF0,0x22,0xE0,0x4A,0x47,0x22,0x2F,0x1B,0xD1,0x31,0x74,0x5B,0xE7};

uint32_t HostingUpsideNotifyStateHandleInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->stateInfo.read(iprot);
          this->__isset.stateInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->eventCreateTimestampMs);
          this->__isset.eventCreateTimestampMs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->handledTimestampMs);
          this->__isset.handledTimestampMs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast82;
          xfer += iprot->readI32(ecast82);
          this->source = (HostingUpsideNotifyStateSource::type)ecast82;
          this->__isset.source = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HostingUpsideNotifyStateHandleInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("HostingUpsideNotifyStateHandleInfo");

  if (this->__isset.stateInfo) {
    xfer += oprot->writeFieldBegin("stateInfo", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->stateInfo.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.eventCreateTimestampMs) {
    xfer += oprot->writeFieldBegin("eventCreateTimestampMs", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->eventCreateTimestampMs);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.handledTimestampMs) {
    xfer += oprot->writeFieldBegin("handledTimestampMs", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->handledTimestampMs);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.source) {
    xfer += oprot->writeFieldBegin("source", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32((int32_t)this->source);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HostingUpsideNotifyStateHandleInfo &a, HostingUpsideNotifyStateHandleInfo &b) {
  using ::std::swap;
  swap(a.stateInfo, b.stateInfo);
  swap(a.eventCreateTimestampMs, b.eventCreateTimestampMs);
  swap(a.handledTimestampMs, b.handledTimestampMs);
  swap(a.source, b.source);
  swap(a.__isset, b.__isset);
}

const char* HostingExecOrderTradeSummary::ascii_fingerprint = "3E519528212B96F04194A73236EADD05";
const uint8_t HostingExecOrderTradeSummary::binary_fingerprint[16] = {0x3E,0x51,0x95,0x28,0x21,0x2B,0x96,0xF0,0x41,0x94,0xA7,0x32,0x36,0xEA,0xDD,0x05};

uint32_t HostingExecOrderTradeSummary::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->upsideTradeTotalVolume);
          this->__isset.upsideTradeTotalVolume = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->upsideTradeAveragePrice);
          this->__isset.upsideTradeAveragePrice = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->upsideTradeRestingVolume);
          this->__isset.upsideTradeRestingVolume = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->tradeListTotalVolume);
          this->__isset.tradeListTotalVolume = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->tradeListAveragePrice);
          this->__isset.tradeListAveragePrice = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HostingExecOrderTradeSummary::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("HostingExecOrderTradeSummary");

  if (this->__isset.upsideTradeTotalVolume) {
    xfer += oprot->writeFieldBegin("upsideTradeTotalVolume", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32(this->upsideTradeTotalVolume);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.upsideTradeAveragePrice) {
    xfer += oprot->writeFieldBegin("upsideTradeAveragePrice", ::apache::thrift::protocol::T_DOUBLE, 2);
    xfer += oprot->writeDouble(this->upsideTradeAveragePrice);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.upsideTradeRestingVolume) {
    xfer += oprot->writeFieldBegin("upsideTradeRestingVolume", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->upsideTradeRestingVolume);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tradeListTotalVolume) {
    xfer += oprot->writeFieldBegin("tradeListTotalVolume", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32(this->tradeListTotalVolume);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tradeListAveragePrice) {
    xfer += oprot->writeFieldBegin("tradeListAveragePrice", ::apache::thrift::protocol::T_DOUBLE, 7);
    xfer += oprot->writeDouble(this->tradeListAveragePrice);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HostingExecOrderTradeSummary &a, HostingExecOrderTradeSummary &b) {
  using ::std::swap;
  swap(a.upsideTradeTotalVolume, b.upsideTradeTotalVolume);
  swap(a.upsideTradeAveragePrice, b.upsideTradeAveragePrice);
  swap(a.upsideTradeRestingVolume, b.upsideTradeRestingVolume);
  swap(a.tradeListTotalVolume, b.tradeListTotalVolume);
  swap(a.tradeListAveragePrice, b.tradeListAveragePrice);
  swap(a.__isset, b.__isset);
}

const char* HostingExecOrder::ascii_fingerprint = "2BFB642D4E2C9FDCBC00C7AB1041C232";
const uint8_t HostingExecOrder::binary_fingerprint[16] = {0x2B,0xFB,0x64,0x2D,0x4E,0x2C,0x9F,0xDC,0xBC,0x00,0xC7,0xAB,0x10,0x41,0xC2,0x32};

uint32_t HostingExecOrder::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->execOrderId);
          this->__isset.execOrderId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->subUserId);
          this->__isset.subUserId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->orderDetail.read(iprot);
          this->__isset.orderDetail = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->contractSummary.read(iprot);
          this->__isset.contractSummary = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->accountSummary.read(iprot);
          this->__isset.accountSummary = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->upsideOrderRef.read(iprot);
          this->__isset.upsideOrderRef = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->orderInputExt.read(iprot);
          this->__isset.orderInputExt = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->subAccountId);
          this->__isset.subAccountId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->stateInfo.read(iprot);
          this->__isset.stateInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->revokeInfo.read(iprot);
          this->__isset.revokeInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->dealInfo.read(iprot);
          this->__isset.dealInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tradeSummary.read(iprot);
          this->__isset.tradeSummary = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->notifyStateHandleInfos.clear();
            uint32_t _size83;
            ::apache::thrift::protocol::TType _etype86;
            xfer += iprot->readListBegin(_etype86, _size83);
            this->notifyStateHandleInfos.resize(_size83);
            uint32_t _i87;
            for (_i87 = 0; _i87 < _size83; ++_i87)
            {
              xfer += this->notifyStateHandleInfos[_i87].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.notifyStateHandleInfos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->relateExecOrderId);
          this->__isset.relateExecOrderId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->createTimestampMs);
          this->__isset.createTimestampMs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lastmodifyTimestampMs);
          this->__isset.lastmodifyTimestampMs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 22:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->version);
          this->__isset.version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 23:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->source);
          this->__isset.source = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 24:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ttlTimestampMs);
          this->__isset.ttlTimestampMs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 25:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->verifyTimestampMs);
          this->__isset.verifyTimestampMs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HostingExecOrder::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("HostingExecOrder");

  if (this->__isset.execOrderId) {
    xfer += oprot->writeFieldBegin("execOrderId", ::apache::thrift::protocol::T_I64, 1);
    xfer += oprot->writeI64(this->execOrderId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.subUserId) {
    xfer += oprot->writeFieldBegin("subUserId", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->subUserId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.orderDetail) {
    xfer += oprot->writeFieldBegin("orderDetail", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->orderDetail.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.contractSummary) {
    xfer += oprot->writeFieldBegin("contractSummary", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->contractSummary.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.accountSummary) {
    xfer += oprot->writeFieldBegin("accountSummary", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->accountSummary.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.upsideOrderRef) {
    xfer += oprot->writeFieldBegin("upsideOrderRef", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->upsideOrderRef.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.orderInputExt) {
    xfer += oprot->writeFieldBegin("orderInputExt", ::apache::thrift::protocol::T_STRUCT, 7);
    xfer += this->orderInputExt.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.subAccountId) {
    xfer += oprot->writeFieldBegin("subAccountId", ::apache::thrift::protocol::T_I64, 8);
    xfer += oprot->writeI64(this->subAccountId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.stateInfo) {
    xfer += oprot->writeFieldBegin("stateInfo", ::apache::thrift::protocol::T_STRUCT, 11);
    xfer += this->stateInfo.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.revokeInfo) {
    xfer += oprot->writeFieldBegin("revokeInfo", ::apache::thrift::protocol::T_STRUCT, 12);
    xfer += this->revokeInfo.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.dealInfo) {
    xfer += oprot->writeFieldBegin("dealInfo", ::apache::thrift::protocol::T_STRUCT, 15);
    xfer += this->dealInfo.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tradeSummary) {
    xfer += oprot->writeFieldBegin("tradeSummary", ::apache::thrift::protocol::T_STRUCT, 16);
    xfer += this->tradeSummary.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.notifyStateHandleInfos) {
    xfer += oprot->writeFieldBegin("notifyStateHandleInfos", ::apache::thrift::protocol::T_LIST, 17);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->notifyStateHandleInfos.size()));
      std::vector<HostingUpsideNotifyStateHandleInfo> ::const_iterator _iter88;
      for (_iter88 = this->notifyStateHandleInfos.begin(); _iter88 != this->notifyStateHandleInfos.end(); ++_iter88)
      {
        xfer += (*_iter88).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.relateExecOrderId) {
    xfer += oprot->writeFieldBegin("relateExecOrderId", ::apache::thrift::protocol::T_I64, 18);
    xfer += oprot->writeI64(this->relateExecOrderId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.createTimestampMs) {
    xfer += oprot->writeFieldBegin("createTimestampMs", ::apache::thrift::protocol::T_I64, 20);
    xfer += oprot->writeI64(this->createTimestampMs);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.lastmodifyTimestampMs) {
    xfer += oprot->writeFieldBegin("lastmodifyTimestampMs", ::apache::thrift::protocol::T_I64, 21);
    xfer += oprot->writeI64(this->lastmodifyTimestampMs);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.version) {
    xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_I32, 22);
    xfer += oprot->writeI32(this->version);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.source) {
    xfer += oprot->writeFieldBegin("source", ::apache::thrift::protocol::T_STRING, 23);
    xfer += oprot->writeString(this->source);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ttlTimestampMs) {
    xfer += oprot->writeFieldBegin("ttlTimestampMs", ::apache::thrift::protocol::T_I64, 24);
    xfer += oprot->writeI64(this->ttlTimestampMs);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.verifyTimestampMs) {
    xfer += oprot->writeFieldBegin("verifyTimestampMs", ::apache::thrift::protocol::T_I64, 25);
    xfer += oprot->writeI64(this->verifyTimestampMs);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HostingExecOrder &a, HostingExecOrder &b) {
  using ::std::swap;
  swap(a.execOrderId, b.execOrderId);
  swap(a.subUserId, b.subUserId);
  swap(a.orderDetail, b.orderDetail);
  swap(a.contractSummary, b.contractSummary);
  swap(a.accountSummary, b.accountSummary);
  swap(a.upsideOrderRef, b.upsideOrderRef);
  swap(a.orderInputExt, b.orderInputExt);
  swap(a.subAccountId, b.subAccountId);
  swap(a.stateInfo, b.stateInfo);
  swap(a.revokeInfo, b.revokeInfo);
  swap(a.dealInfo, b.dealInfo);
  swap(a.tradeSummary, b.tradeSummary);
  swap(a.notifyStateHandleInfos, b.notifyStateHandleInfos);
  swap(a.relateExecOrderId, b.relateExecOrderId);
  swap(a.createTimestampMs, b.createTimestampMs);
  swap(a.lastmodifyTimestampMs, b.lastmodifyTimestampMs);
  swap(a.version, b.version);
  swap(a.source, b.source);
  swap(a.ttlTimestampMs, b.ttlTimestampMs);
  swap(a.verifyTimestampMs, b.verifyTimestampMs);
  swap(a.__isset, b.__isset);
}

const char* CTPTradeID::ascii_fingerprint = "66E694018C17E5B65A59AE8F55CCA3CD";
const uint8_t CTPTradeID::binary_fingerprint[16] = {0x66,0xE6,0x94,0x01,0x8C,0x17,0xE5,0xB6,0x5A,0x59,0xAE,0x8F,0x55,0xCC,0xA3,0xCD};

uint32_t CTPTradeID::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tradeId);
          this->__isset.tradeId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTPTradeID::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CTPTradeID");

  if (this->__isset.tradeId) {
    xfer += oprot->writeFieldBegin("tradeId", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->tradeId);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CTPTradeID &a, CTPTradeID &b) {
  using ::std::swap;
  swap(a.tradeId, b.tradeId);
  swap(a.__isset, b.__isset);
}

const char* ESunny3TradeID::ascii_fingerprint = "66E694018C17E5B65A59AE8F55CCA3CD";
const uint8_t ESunny3TradeID::binary_fingerprint[16] = {0x66,0xE6,0x94,0x01,0x8C,0x17,0xE5,0xB6,0x5A,0x59,0xAE,0x8F,0x55,0xCC,0xA3,0xCD};

uint32_t ESunny3TradeID::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->matchNo);
          this->__isset.matchNo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ESunny3TradeID::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ESunny3TradeID");

  if (this->__isset.matchNo) {
    xfer += oprot->writeFieldBegin("matchNo", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->matchNo);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ESunny3TradeID &a, ESunny3TradeID &b) {
  using ::std::swap;
  swap(a.matchNo, b.matchNo);
  swap(a.__isset, b.__isset);
}

const char* ESunny9TradeID::ascii_fingerprint = "66E694018C17E5B65A59AE8F55CCA3CD";
const uint8_t ESunny9TradeID::binary_fingerprint[16] = {0x66,0xE6,0x94,0x01,0x8C,0x17,0xE5,0xB6,0x5A,0x59,0xAE,0x8F,0x55,0xCC,0xA3,0xCD};

uint32_t ESunny9TradeID::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->matchNo);
          this->__isset.matchNo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ESunny9TradeID::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ESunny9TradeID");

  if (this->__isset.matchNo) {
    xfer += oprot->writeFieldBegin("matchNo", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->matchNo);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ESunny9TradeID &a, ESunny9TradeID &b) {
  using ::std::swap;
  swap(a.matchNo, b.matchNo);
  swap(a.__isset, b.__isset);
}

const char* HostingExecUpsideTradeID::ascii_fingerprint = "CC67F666C7DB8C386FAD90A42F0C6A03";
const uint8_t HostingExecUpsideTradeID::binary_fingerprint[16] = {0xCC,0x67,0xF6,0x66,0xC7,0xDB,0x8C,0x38,0x6F,0xAD,0x90,0xA4,0x2F,0x0C,0x6A,0x03};

uint32_t HostingExecUpsideTradeID::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ctpTradeId.read(iprot);
          this->__isset.ctpTradeId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->esunny3TradeId.read(iprot);
          this->__isset.esunny3TradeId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->esunny9TradeId.read(iprot);
          this->__isset.esunny9TradeId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HostingExecUpsideTradeID::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("HostingExecUpsideTradeID");

  if (this->__isset.ctpTradeId) {
    xfer += oprot->writeFieldBegin("ctpTradeId", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ctpTradeId.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.esunny3TradeId) {
    xfer += oprot->writeFieldBegin("esunny3TradeId", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->esunny3TradeId.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.esunny9TradeId) {
    xfer += oprot->writeFieldBegin("esunny9TradeId", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->esunny9TradeId.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HostingExecUpsideTradeID &a, HostingExecUpsideTradeID &b) {
  using ::std::swap;
  swap(a.ctpTradeId, b.ctpTradeId);
  swap(a.esunny3TradeId, b.esunny3TradeId);
  swap(a.esunny9TradeId, b.esunny9TradeId);
  swap(a.__isset, b.__isset);
}

const char* HostingExecTrade::ascii_fingerprint = "48450CB3EEEEB9DF77026913A4456770";
const uint8_t HostingExecTrade::binary_fingerprint[16] = {0x48,0x45,0x0C,0xB3,0xEE,0xEE,0xB9,0xDF,0x77,0x02,0x69,0x13,0xA4,0x45,0x67,0x70};

uint32_t HostingExecTrade::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->execTradeId);
          this->__isset.execTradeId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->execOrderId);
          this->__isset.execOrderId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->subUserId);
          this->__isset.subUserId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->subAccountId);
          this->__isset.subAccountId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->contractSummary.read(iprot);
          this->__isset.contractSummary = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->accountSummary.read(iprot);
          this->__isset.accountSummary = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->relatedTradeLegIds.clear();
            uint32_t _size89;
            ::apache::thrift::protocol::TType _etype92;
            xfer += iprot->readListBegin(_etype92, _size89);
            this->relatedTradeLegIds.resize(_size89);
            uint32_t _i93;
            for (_i93 = 0; _i93 < _size89; ++_i93)
            {
              xfer += iprot->readI64(this->relatedTradeLegIds[_i93]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.relatedTradeLegIds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->tradePrice);
          this->__isset.tradePrice = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->tradeVolume);
          this->__isset.tradeVolume = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->createTimestampMs);
          this->__isset.createTimestampMs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lastmodifyTimestampMs);
          this->__isset.lastmodifyTimestampMs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->relatedTradeLegPrices.clear();
            uint32_t _size94;
            ::apache::thrift::protocol::TType _etype97;
            xfer += iprot->readListBegin(_etype97, _size94);
            this->relatedTradeLegPrices.resize(_size94);
            uint32_t _i98;
            for (_i98 = 0; _i98 < _size94; ++_i98)
            {
              xfer += iprot->readDouble(this->relatedTradeLegPrices[_i98]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.relatedTradeLegPrices = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast99;
          xfer += iprot->readI32(ecast99);
          this->orderTradeDirection = (HostingExecOrderTradeDirection::type)ecast99;
          this->__isset.orderTradeDirection = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->relatedTradeLegTradeDirections.clear();
            uint32_t _size100;
            ::apache::thrift::protocol::TType _etype103;
            xfer += iprot->readListBegin(_etype103, _size100);
            this->relatedTradeLegTradeDirections.resize(_size100);
            uint32_t _i104;
            for (_i104 = 0; _i104 < _size100; ++_i104)
            {
              int32_t ecast105;
              xfer += iprot->readI32(ecast105);
              this->relatedTradeLegTradeDirections[_i104] = (HostingExecTradeDirection::type)ecast105;
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.relatedTradeLegTradeDirections = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HostingExecTrade::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("HostingExecTrade");

  if (this->__isset.execTradeId) {
    xfer += oprot->writeFieldBegin("execTradeId", ::apache::thrift::protocol::T_I64, 1);
    xfer += oprot->writeI64(this->execTradeId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.execOrderId) {
    xfer += oprot->writeFieldBegin("execOrderId", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->execOrderId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.subUserId) {
    xfer += oprot->writeFieldBegin("subUserId", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->subUserId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.subAccountId) {
    xfer += oprot->writeFieldBegin("subAccountId", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->subAccountId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.contractSummary) {
    xfer += oprot->writeFieldBegin("contractSummary", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->contractSummary.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.accountSummary) {
    xfer += oprot->writeFieldBegin("accountSummary", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->accountSummary.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.relatedTradeLegIds) {
    xfer += oprot->writeFieldBegin("relatedTradeLegIds", ::apache::thrift::protocol::T_LIST, 7);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->relatedTradeLegIds.size()));
      std::vector<int64_t> ::const_iterator _iter106;
      for (_iter106 = this->relatedTradeLegIds.begin(); _iter106 != this->relatedTradeLegIds.end(); ++_iter106)
      {
        xfer += oprot->writeI64((*_iter106));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tradePrice) {
    xfer += oprot->writeFieldBegin("tradePrice", ::apache::thrift::protocol::T_DOUBLE, 8);
    xfer += oprot->writeDouble(this->tradePrice);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tradeVolume) {
    xfer += oprot->writeFieldBegin("tradeVolume", ::apache::thrift::protocol::T_I32, 9);
    xfer += oprot->writeI32(this->tradeVolume);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.createTimestampMs) {
    xfer += oprot->writeFieldBegin("createTimestampMs", ::apache::thrift::protocol::T_I64, 10);
    xfer += oprot->writeI64(this->createTimestampMs);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.lastmodifyTimestampMs) {
    xfer += oprot->writeFieldBegin("lastmodifyTimestampMs", ::apache::thrift::protocol::T_I64, 11);
    xfer += oprot->writeI64(this->lastmodifyTimestampMs);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.relatedTradeLegPrices) {
    xfer += oprot->writeFieldBegin("relatedTradeLegPrices", ::apache::thrift::protocol::T_LIST, 12);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->relatedTradeLegPrices.size()));
      std::vector<double> ::const_iterator _iter107;
      for (_iter107 = this->relatedTradeLegPrices.begin(); _iter107 != this->relatedTradeLegPrices.end(); ++_iter107)
      {
        xfer += oprot->writeDouble((*_iter107));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.orderTradeDirection) {
    xfer += oprot->writeFieldBegin("orderTradeDirection", ::apache::thrift::protocol::T_I32, 13);
    xfer += oprot->writeI32((int32_t)this->orderTradeDirection);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.relatedTradeLegTradeDirections) {
    xfer += oprot->writeFieldBegin("relatedTradeLegTradeDirections", ::apache::thrift::protocol::T_LIST, 14);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->relatedTradeLegTradeDirections.size()));
      std::vector<HostingExecTradeDirection::type> ::const_iterator _iter108;
      for (_iter108 = this->relatedTradeLegTradeDirections.begin(); _iter108 != this->relatedTradeLegTradeDirections.end(); ++_iter108)
      {
        xfer += oprot->writeI32((int32_t)(*_iter108));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HostingExecTrade &a, HostingExecTrade &b) {
  using ::std::swap;
  swap(a.execTradeId, b.execTradeId);
  swap(a.execOrderId, b.execOrderId);
  swap(a.subUserId, b.subUserId);
  swap(a.subAccountId, b.subAccountId);
  swap(a.contractSummary, b.contractSummary);
  swap(a.accountSummary, b.accountSummary);
  swap(a.relatedTradeLegIds, b.relatedTradeLegIds);
  swap(a.tradePrice, b.tradePrice);
  swap(a.tradeVolume, b.tradeVolume);
  swap(a.createTimestampMs, b.createTimestampMs);
  swap(a.lastmodifyTimestampMs, b.lastmodifyTimestampMs);
  swap(a.relatedTradeLegPrices, b.relatedTradeLegPrices);
  swap(a.orderTradeDirection, b.orderTradeDirection);
  swap(a.relatedTradeLegTradeDirections, b.relatedTradeLegTradeDirections);
  swap(a.__isset, b.__isset);
}

const char* HostingExecTradeLegInfo::ascii_fingerprint = "6782A99EAB805B72E5A6CC5F9B48FC3C";
const uint8_t HostingExecTradeLegInfo::binary_fingerprint[16] = {0x67,0x82,0xA9,0x9E,0xAB,0x80,0x5B,0x72,0xE5,0xA6,0xCC,0x5F,0x9B,0x48,0xFC,0x3C};

uint32_t HostingExecTradeLegInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->legTradePrice);
          this->__isset.legTradePrice = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->legTradeVolume);
          this->__isset.legTradeVolume = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->legTradeDateTime);
          this->__isset.legTradeDateTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->legUpsideTradeId.read(iprot);
          this->__isset.legUpsideTradeId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast109;
          xfer += iprot->readI32(ecast109);
          this->legUpsideTradeDirection = (HostingExecTradeDirection::type)ecast109;
          this->__isset.legUpsideTradeDirection = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HostingExecTradeLegInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("HostingExecTradeLegInfo");

  if (this->__isset.legTradePrice) {
    xfer += oprot->writeFieldBegin("legTradePrice", ::apache::thrift::protocol::T_DOUBLE, 1);
    xfer += oprot->writeDouble(this->legTradePrice);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.legTradeVolume) {
    xfer += oprot->writeFieldBegin("legTradeVolume", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->legTradeVolume);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.legTradeDateTime) {
    xfer += oprot->writeFieldBegin("legTradeDateTime", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->legTradeDateTime);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.legUpsideTradeId) {
    xfer += oprot->writeFieldBegin("legUpsideTradeId", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->legUpsideTradeId.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.legUpsideTradeDirection) {
    xfer += oprot->writeFieldBegin("legUpsideTradeDirection", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32((int32_t)this->legUpsideTradeDirection);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HostingExecTradeLegInfo &a, HostingExecTradeLegInfo &b) {
  using ::std::swap;
  swap(a.legTradePrice, b.legTradePrice);
  swap(a.legTradeVolume, b.legTradeVolume);
  swap(a.legTradeDateTime, b.legTradeDateTime);
  swap(a.legUpsideTradeId, b.legUpsideTradeId);
  swap(a.legUpsideTradeDirection, b.legUpsideTradeDirection);
  swap(a.__isset, b.__isset);
}

const char* HostingExecTradeLeg::ascii_fingerprint = "9643F20FF955018CAD841629689D7AE2";
const uint8_t HostingExecTradeLeg::binary_fingerprint[16] = {0x96,0x43,0xF2,0x0F,0xF9,0x55,0x01,0x8C,0xAD,0x84,0x16,0x29,0x68,0x9D,0x7A,0xE2};

uint32_t HostingExecTradeLeg::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->execTradeLegId);
          this->__isset.execTradeLegId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->execOrderId);
          this->__isset.execOrderId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->relatedExecTradeId);
          this->__isset.relatedExecTradeId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->legIndex);
          this->__isset.legIndex = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->legContractSummary.read(iprot);
          this->__isset.legContractSummary = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tradeLegInfo.read(iprot);
          this->__isset.tradeLegInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->accountSummary.read(iprot);
          this->__isset.accountSummary = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->subUserId);
          this->__isset.subUserId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->createTimestampMs);
          this->__isset.createTimestampMs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lastmodifyTimestampMs);
          this->__isset.lastmodifyTimestampMs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->subAccountId);
          this->__isset.subAccountId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HostingExecTradeLeg::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("HostingExecTradeLeg");

  if (this->__isset.execTradeLegId) {
    xfer += oprot->writeFieldBegin("execTradeLegId", ::apache::thrift::protocol::T_I64, 1);
    xfer += oprot->writeI64(this->execTradeLegId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.execOrderId) {
    xfer += oprot->writeFieldBegin("execOrderId", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->execOrderId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.relatedExecTradeId) {
    xfer += oprot->writeFieldBegin("relatedExecTradeId", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->relatedExecTradeId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.legIndex) {
    xfer += oprot->writeFieldBegin("legIndex", ::apache::thrift::protocol::T_I16, 4);
    xfer += oprot->writeI16(this->legIndex);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.legContractSummary) {
    xfer += oprot->writeFieldBegin("legContractSummary", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->legContractSummary.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tradeLegInfo) {
    xfer += oprot->writeFieldBegin("tradeLegInfo", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->tradeLegInfo.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.accountSummary) {
    xfer += oprot->writeFieldBegin("accountSummary", ::apache::thrift::protocol::T_STRUCT, 7);
    xfer += this->accountSummary.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.subUserId) {
    xfer += oprot->writeFieldBegin("subUserId", ::apache::thrift::protocol::T_I32, 8);
    xfer += oprot->writeI32(this->subUserId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.createTimestampMs) {
    xfer += oprot->writeFieldBegin("createTimestampMs", ::apache::thrift::protocol::T_I64, 9);
    xfer += oprot->writeI64(this->createTimestampMs);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.lastmodifyTimestampMs) {
    xfer += oprot->writeFieldBegin("lastmodifyTimestampMs", ::apache::thrift::protocol::T_I64, 10);
    xfer += oprot->writeI64(this->lastmodifyTimestampMs);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.subAccountId) {
    xfer += oprot->writeFieldBegin("subAccountId", ::apache::thrift::protocol::T_I64, 11);
    xfer += oprot->writeI64(this->subAccountId);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HostingExecTradeLeg &a, HostingExecTradeLeg &b) {
  using ::std::swap;
  swap(a.execTradeLegId, b.execTradeLegId);
  swap(a.execOrderId, b.execOrderId);
  swap(a.relatedExecTradeId, b.relatedExecTradeId);
  swap(a.legIndex, b.legIndex);
  swap(a.legContractSummary, b.legContractSummary);
  swap(a.tradeLegInfo, b.tradeLegInfo);
  swap(a.accountSummary, b.accountSummary);
  swap(a.subUserId, b.subUserId);
  swap(a.createTimestampMs, b.createTimestampMs);
  swap(a.lastmodifyTimestampMs, b.lastmodifyTimestampMs);
  swap(a.subAccountId, b.subAccountId);
  swap(a.__isset, b.__isset);
}

}}} // namespace
