/**
 * Autogenerated by Thrift Compiler (0.9.1)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "broker_types.h"

#include <algorithm>



int _kBrokerAccessStatusValues[] = {
  BrokerAccessStatus::NEW,
  BrokerAccessStatus::EDIT,
  BrokerAccessStatus::VERIFIED_CORRECT,
  BrokerAccessStatus::SYNCHRONIZED
};
const char* _kBrokerAccessStatusNames[] = {
  "NEW",
  "EDIT",
  "VERIFIED_CORRECT",
  "SYNCHRONIZED"
};
const std::map<int, const char*> _BrokerAccessStatus_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kBrokerAccessStatusValues, _kBrokerAccessStatusNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kBrokerAccessWorkingStatusValues[] = {
  BrokerAccessWorkingStatus::NOT_WORKING,
  BrokerAccessWorkingStatus::WORKING
};
const char* _kBrokerAccessWorkingStatusNames[] = {
  "NOT_WORKING",
  "WORKING"
};
const std::map<int, const char*> _BrokerAccessWorkingStatus_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kBrokerAccessWorkingStatusValues, _kBrokerAccessWorkingStatusNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTechPlatformEnvValues[] = {
  TechPlatformEnv::NONE,
  TechPlatformEnv::REAL,
  TechPlatformEnv::SIM
};
const char* _kTechPlatformEnvNames[] = {
  "NONE",
  "REAL",
  "SIM"
};
const std::map<int, const char*> _TechPlatformEnv_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kTechPlatformEnvValues, _kTechPlatformEnvNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kBrokerPlatformValues[] = {
  BrokerPlatform::NONE,
  BrokerPlatform::CTP,
  BrokerPlatform::ESUNNY,
  BrokerPlatform::SP,
  BrokerPlatform::ESUNNY_3
};
const char* _kBrokerPlatformNames[] = {
  "NONE",
  "CTP",
  "ESUNNY",
  "SP",
  "ESUNNY_3"
};
const std::map<int, const char*> _BrokerPlatform_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kBrokerPlatformValues, _kBrokerPlatformNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kBrokerErrorCodeValues[] = {
  BrokerErrorCode::BROKER_NOT_FOUND,
  BrokerErrorCode::BROKER_ENG_NAME_EXIST,
  BrokerErrorCode::BROKER_CN_NAME_EXIST,
  BrokerErrorCode::BROKER_ACCESS_NOT_VERIFIED,
  BrokerErrorCode::BROKER_EXIST,
  BrokerErrorCode::BROKER_ACCESS_EXIST,
  BrokerErrorCode::BROKER_ACCESS_NOT_FOUND,
  BrokerErrorCode::BROKER_ACCESS_BROKERID_NO_CHANGE,
  BrokerErrorCode::BROKER_ACCESS_PLATFORM_NO_CHANGE,
  BrokerErrorCode::BROKER_ACCESS_NOT_WORKING,
  BrokerErrorCode::BROKER_ACCESS_WORKING,
  BrokerErrorCode::BROKER_ACCESS_ADDRESS_ERROR,
  BrokerErrorCode::BROKER_ACCESS_ADDRESS_PORT_ERROR,
  BrokerErrorCode::BROKER_ACCESS_TECH_PLATFORM_MUST_SET,
  BrokerErrorCode::BROKER_ACCESS_TRADE_ADDRESS_MUST_SET,
  BrokerErrorCode::BROKER_ACCESS_TECH_PLATFORM_ENV_MUST_SET,
  BrokerErrorCode::BROKER_ACCESS_MAPPING_FILE_MUST_SET,
  BrokerErrorCode::BROKER_ACCESS_CUSTOM_INFO_MUST_SET,
  BrokerErrorCode::BROKER_ACCESS_PLATFORM_ENV_NO_CHANGE,
  BrokerErrorCode::BROKER_ACCESS_CUSTOM_INFO_NO_CHANGE
};
const char* _kBrokerErrorCodeNames[] = {
  "BROKER_NOT_FOUND",
  "BROKER_ENG_NAME_EXIST",
  "BROKER_CN_NAME_EXIST",
  "BROKER_ACCESS_NOT_VERIFIED",
  "BROKER_EXIST",
  "BROKER_ACCESS_EXIST",
  "BROKER_ACCESS_NOT_FOUND",
  "BROKER_ACCESS_BROKERID_NO_CHANGE",
  "BROKER_ACCESS_PLATFORM_NO_CHANGE",
  "BROKER_ACCESS_NOT_WORKING",
  "BROKER_ACCESS_WORKING",
  "BROKER_ACCESS_ADDRESS_ERROR",
  "BROKER_ACCESS_ADDRESS_PORT_ERROR",
  "BROKER_ACCESS_TECH_PLATFORM_MUST_SET",
  "BROKER_ACCESS_TRADE_ADDRESS_MUST_SET",
  "BROKER_ACCESS_TECH_PLATFORM_ENV_MUST_SET",
  "BROKER_ACCESS_MAPPING_FILE_MUST_SET",
  "BROKER_ACCESS_CUSTOM_INFO_MUST_SET",
  "BROKER_ACCESS_PLATFORM_ENV_NO_CHANGE",
  "BROKER_ACCESS_CUSTOM_INFO_NO_CHANGE"
};
const std::map<int, const char*> _BrokerErrorCode_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(20, _kBrokerErrorCodeValues, _kBrokerErrorCodeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

const char* AccessAddress::ascii_fingerprint = "5B2E301BB39FF8267F51DF4E0A3C43D2";
const uint8_t AccessAddress::binary_fingerprint[16] = {0x5B,0x2E,0x30,0x1B,0xB3,0x9F,0xF8,0x26,0x7F,0x51,0xDF,0x4E,0x0A,0x3C,0x43,0xD2};

uint32_t AccessAddress::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->address);
          this->__isset.address = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->port);
          this->__isset.port = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccessAddress::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccessAddress");

  if (this->__isset.address) {
    xfer += oprot->writeFieldBegin("address", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->address);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.port) {
    xfer += oprot->writeFieldBegin("port", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->port);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AccessAddress &a, AccessAddress &b) {
  using ::std::swap;
  swap(a.address, b.address);
  swap(a.port, b.port);
  swap(a.__isset, b.__isset);
}

const char* BrokerEntry::ascii_fingerprint = "1F3C5E2048F7CCE93BE90EC362CD6A05";
const uint8_t BrokerEntry::binary_fingerprint[16] = {0x1F,0x3C,0x5E,0x20,0x48,0xF7,0xCC,0xE9,0x3B,0xE9,0x0E,0xC3,0x62,0xCD,0x6A,0x05};

uint32_t BrokerEntry::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->brokerId);
          this->__isset.brokerId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->engName);
          this->__isset.engName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cnName);
          this->__isset.cnName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->note);
          this->__isset.note = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lastModityTimestamp);
          this->__isset.lastModityTimestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->createTimestamp);
          this->__isset.createTimestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BrokerEntry::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("BrokerEntry");

  if (this->__isset.brokerId) {
    xfer += oprot->writeFieldBegin("brokerId", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32(this->brokerId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.engName) {
    xfer += oprot->writeFieldBegin("engName", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->engName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cnName) {
    xfer += oprot->writeFieldBegin("cnName", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->cnName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.note) {
    xfer += oprot->writeFieldBegin("note", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->note);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.lastModityTimestamp) {
    xfer += oprot->writeFieldBegin("lastModityTimestamp", ::apache::thrift::protocol::T_I64, 6);
    xfer += oprot->writeI64(this->lastModityTimestamp);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.createTimestamp) {
    xfer += oprot->writeFieldBegin("createTimestamp", ::apache::thrift::protocol::T_I64, 7);
    xfer += oprot->writeI64(this->createTimestamp);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BrokerEntry &a, BrokerEntry &b) {
  using ::std::swap;
  swap(a.brokerId, b.brokerId);
  swap(a.engName, b.engName);
  swap(a.cnName, b.cnName);
  swap(a.note, b.note);
  swap(a.lastModityTimestamp, b.lastModityTimestamp);
  swap(a.createTimestamp, b.createTimestamp);
  swap(a.__isset, b.__isset);
}

const char* BrokerAccessEntry::ascii_fingerprint = "B02E622F8C0C2B87567AEB9C5F33B325";
const uint8_t BrokerAccessEntry::binary_fingerprint[16] = {0xB0,0x2E,0x62,0x2F,0x8C,0x0C,0x2B,0x87,0x56,0x7A,0xEB,0x9C,0x5F,0x33,0xB3,0x25};

uint32_t BrokerAccessEntry::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->entryId);
          this->__isset.entryId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->brokerId);
          this->__isset.brokerId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast0;
          xfer += iprot->readI32(ecast0);
          this->platform = (BrokerPlatform::type)ecast0;
          this->__isset.platform = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->tradeAddresses.clear();
            uint32_t _size1;
            ::apache::thrift::protocol::TType _etype4;
            xfer += iprot->readListBegin(_etype4, _size1);
            this->tradeAddresses.resize(_size1);
            uint32_t _i5;
            for (_i5 = 0; _i5 < _size1; ++_i5)
            {
              xfer += this->tradeAddresses[_i5].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.tradeAddresses = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->customInfoMap.clear();
            uint32_t _size6;
            ::apache::thrift::protocol::TType _ktype7;
            ::apache::thrift::protocol::TType _vtype8;
            xfer += iprot->readMapBegin(_ktype7, _vtype8, _size6);
            uint32_t _i10;
            for (_i10 = 0; _i10 < _size6; ++_i10)
            {
              std::string _key11;
              xfer += iprot->readString(_key11);
              std::string& _val12 = this->customInfoMap[_key11];
              xfer += iprot->readString(_val12);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.customInfoMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast13;
          xfer += iprot->readI32(ecast13);
          this->status = (BrokerAccessStatus::type)ecast13;
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lastModityTimestamp);
          this->__isset.lastModityTimestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->createTimestamp);
          this->__isset.createTimestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast14;
          xfer += iprot->readI32(ecast14);
          this->workingStatus = (BrokerAccessWorkingStatus::type)ecast14;
          this->__isset.workingStatus = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast15;
          xfer += iprot->readI32(ecast15);
          this->techPlatformEnv = (TechPlatformEnv::type)ecast15;
          this->__isset.techPlatformEnv = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->accessName);
          this->__isset.accessName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->quotaAddresses.clear();
            uint32_t _size16;
            ::apache::thrift::protocol::TType _etype19;
            xfer += iprot->readListBegin(_etype19, _size16);
            this->quotaAddresses.resize(_size16);
            uint32_t _i20;
            for (_i20 = 0; _i20 < _size16; ++_i20)
            {
              xfer += this->quotaAddresses[_i20].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.quotaAddresses = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BrokerAccessEntry::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("BrokerAccessEntry");

  if (this->__isset.entryId) {
    xfer += oprot->writeFieldBegin("entryId", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32(this->entryId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.brokerId) {
    xfer += oprot->writeFieldBegin("brokerId", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->brokerId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.platform) {
    xfer += oprot->writeFieldBegin("platform", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32((int32_t)this->platform);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tradeAddresses) {
    xfer += oprot->writeFieldBegin("tradeAddresses", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->tradeAddresses.size()));
      std::vector<AccessAddress> ::const_iterator _iter21;
      for (_iter21 = this->tradeAddresses.begin(); _iter21 != this->tradeAddresses.end(); ++_iter21)
      {
        xfer += (*_iter21).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.customInfoMap) {
    xfer += oprot->writeFieldBegin("customInfoMap", ::apache::thrift::protocol::T_MAP, 5);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->customInfoMap.size()));
      std::map<std::string, std::string> ::const_iterator _iter22;
      for (_iter22 = this->customInfoMap.begin(); _iter22 != this->customInfoMap.end(); ++_iter22)
      {
        xfer += oprot->writeString(_iter22->first);
        xfer += oprot->writeString(_iter22->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.status) {
    xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32((int32_t)this->status);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.lastModityTimestamp) {
    xfer += oprot->writeFieldBegin("lastModityTimestamp", ::apache::thrift::protocol::T_I64, 7);
    xfer += oprot->writeI64(this->lastModityTimestamp);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.createTimestamp) {
    xfer += oprot->writeFieldBegin("createTimestamp", ::apache::thrift::protocol::T_I64, 8);
    xfer += oprot->writeI64(this->createTimestamp);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.workingStatus) {
    xfer += oprot->writeFieldBegin("workingStatus", ::apache::thrift::protocol::T_I32, 9);
    xfer += oprot->writeI32((int32_t)this->workingStatus);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.techPlatformEnv) {
    xfer += oprot->writeFieldBegin("techPlatformEnv", ::apache::thrift::protocol::T_I32, 10);
    xfer += oprot->writeI32((int32_t)this->techPlatformEnv);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.accessName) {
    xfer += oprot->writeFieldBegin("accessName", ::apache::thrift::protocol::T_STRING, 11);
    xfer += oprot->writeString(this->accessName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.quotaAddresses) {
    xfer += oprot->writeFieldBegin("quotaAddresses", ::apache::thrift::protocol::T_LIST, 12);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->quotaAddresses.size()));
      std::vector<AccessAddress> ::const_iterator _iter23;
      for (_iter23 = this->quotaAddresses.begin(); _iter23 != this->quotaAddresses.end(); ++_iter23)
      {
        xfer += (*_iter23).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BrokerAccessEntry &a, BrokerAccessEntry &b) {
  using ::std::swap;
  swap(a.entryId, b.entryId);
  swap(a.brokerId, b.brokerId);
  swap(a.platform, b.platform);
  swap(a.tradeAddresses, b.tradeAddresses);
  swap(a.customInfoMap, b.customInfoMap);
  swap(a.status, b.status);
  swap(a.lastModityTimestamp, b.lastModityTimestamp);
  swap(a.createTimestamp, b.createTimestamp);
  swap(a.workingStatus, b.workingStatus);
  swap(a.techPlatformEnv, b.techPlatformEnv);
  swap(a.accessName, b.accessName);
  swap(a.quotaAddresses, b.quotaAddresses);
  swap(a.__isset, b.__isset);
}


